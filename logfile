Vim: Warning: Output is not to a terminal
chdir(/usr/local/share/vim)[?25l[J
fchdir() to previous dir[J
could not source "$VIM/vimrc"[J
chdir(/home/vimtest)[J
fchdir() to previous dir[J
sourcing "$HOME/.vimrc"[J
line 1: source ~/.vim/bundles.vim[J

chdir(/home/vimtest/.vim)[J
fchdir() to previous dir[J
line 1: sourcing "/home/vimtest/.vim/bundles.vim"[J
line 1: set nocompatible[J

line 2: filetype off[J

Searching for "ftoff.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after"[J
Searching for "/home/vimtest/.vim/ftoff.vim"[J
Searching for "/usr/local/share/vim/vimfiles/ftoff.vim"[J
Searching for "/usr/local/share/vim/vim73/ftoff.vim"[J
chdir(/usr/local/share/vim/vim73)[J
fchdir() to previous dir[J
line 2: sourcing "/usr/local/share/vim/vim73/ftoff.vim"[J
line 1: " Vim support file to switch off detection of file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2001 Jun 11[J

line 5: [J

line 6: if exists("did_load_filetypes")[J

line 7:   unlet did_load_filetypes[J

line 8: endif[J

line 9: [J

line 10: " Remove all autocommands in the filetypedetect group[J

line 11: silent! au! filetypedetect *[J

finished sourcing /usr/local/share/vim/vim73/ftoff.vim[J
continuing in /home/vimtest/.vim/bundles.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/ftoff.vim"[J
Searching for "/home/vimtest/.vim/after/ftoff.vim"[J
line 3: filetype plugin indent on[J

Searching for "filetype.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after"[J
Searching for "/home/vimtest/.vim/filetype.vim"[J
Searching for "/usr/local/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/local/share/vim/vim73/filetype.vim"[J
chdir(/usr/local/share/vim/vim73)[J
fchdir() to previous dir[J
line 3: sourcing "/usr/local/share/vim/vim73/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2010 Jul 30[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

line 9: endif[J

line 10: let did_load_filetypes = 1[J

line 11: [J

line 12: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 13: let s:cpo_save = &cpo[J

line 14: set cpo&vim[J

line 15: [J

line 16: augroup filetypedetect[J

line 17: [J

line 18: " Ignored extensions[J

line 19: if exists("*fnameescape")[J

line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.rpmsave,?\+.rpmnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))[J

line 28: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short[J

line 32: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif[J

line 33: elseif &verbose > 0[J

line 34:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"[J

line 35: endif[J

line 36: [J

line 37: " Pattern used to match file names which should not be inspected.[J

line 38: " Currently finds compressed files.[J

line 39: if !exists("g:ft_ignore_pat")[J

line 40:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'[J

line 41: endif[J

line 42: [J

line 43: " Function used for patterns that end in a star: don't set the filetype if the[J

line 44: " file name matches ft_ignore_pat.[J

line 45: func! s:StarSetf(ft)[J

line 50: [J

line 51: " Abaqus or Trasys[J

line 52: au BufNewFile,BufRead *.inp^I^I^Icall s:Check_inp()[J

line 53: [J

line 54: func! s:Check_inp()[J

line 73: [J

line 74: " A-A-P recipe[J

line 75: au BufNewFile,BufRead *.aap^I^I^Isetf aap[J

line 76: [J

line 77: " A2ps printing utility[J

line 78: au BufNewFile,BufRead etc/a2ps.cfg,etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps[J

line 79: [J

line 80: " ABAB/4[J

line 81: au BufNewFile,BufRead *.abap^I^I^Isetf abap[J

line 82: [J

line 83: " ABC music notation[J

line 84: au BufNewFile,BufRead *.abc^I^I^Isetf abc[J

line 85: [J

line 86: " ABEL[J

line 87: au BufNewFile,BufRead *.abl^I^I^Isetf abel[J

line 88: [J

line 89: " AceDB[J

line 90: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb[J

line 91: [J

line 92: " Ada (83, 9X, 95)[J

line 93: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada[J

line 94: if has("vms")[J

line 95:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada[J

line 96: else[J

line 97:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada[J

line 98: endif[J

line 99: [J

line 100: " AHDL[J

line 101: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl[J

line 102: [J

line 103: " AMPL[J

line 104: au BufNewFile,BufRead *.run^I^I^Isetf ampl[J

line 105: [J

line 106: " Ant[J

line 107: au BufNewFile,BufRead build.xml^I^I^Isetf ant[J

line 108: [J

line 109: " Apache style config file[J

line 110: au BufNewFile,BufRead proftpd.conf*^I^Icall s:StarSetf('apachestyle')[J

line 111: [J

line 112: " Apache config file[J

line 113: au BufNewFile,BufRead .htaccess,/etc/httpd/*.conf^I^I setf apache[J

line 114: au BufNewFile,BufRead httpd.conf*,srm.conf*,access.conf*,apache.conf*,apache2.conf*,/etc/apache2/*.conf*,/etc/httpd/conf.d/*.conf* call s:StarSetf('apache')[J

line 115: [J

line 116: " XA65 MOS6510 cross assembler[J

line 117: au BufNewFile,BufRead *.a65^I^I^Isetf a65[J

line 118: [J

line 119: " Applescript[J

line 120: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript[J

line 121: [J

line 122: " Applix ELF[J

line 124: au BufNewFile,BufRead *.am if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif[J

line 125: [J

line 126: " ALSA configuration[J

line 127: au BufNewFile,BufRead ~/.asoundrc,/usr/share/alsa/alsa.conf,/etc/asound.conf^Isetf alsaconf[J

line 128: [J

line 129: " Arc Macro Language[J

line 130: au BufNewFile,BufRead *.aml^I^I^Isetf aml[J

line 131: [J

line 132: " Arch Inventory file[J

line 133: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch[J

line 134: [J

line 135: " ART*Enterprise (formerly ART-IM)[J

line 136: au BufNewFile,BufRead *.art^I^I^Isetf art[J

line 137: [J

line 138: " ASN.1[J

line 139: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn[J

line 140: [J

line 141: " Active Server Pages (with Visual Basic Script)[J

line 147: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif[J

line 148: [J

line 149: " Active Server Pages (with Perl or Visual Basic Script)[J

line 157: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif[J

line 158: [J

line 159: " Grub (must be before catch *.lst)[J

line 160: au BufNewFile,BufRead /boot/grub/menu.lst,/boot/grub/grub.conf,/etc/grub.conf^Isetf grub[J

line 161: [J

line 162: " Assembly (all kinds)[J

line 163: " *.lst is not pure assembly, it has two extra columns (address, byte codes)[J

line 164: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall s:FTasm()[J

line 165: [J

line 166: " This function checks for the kind of assembly that is wanted by the user, or[J

line 167: " can be detected from the first five lines of the file.[J

line 168: func! s:FTasm()[J

line 189: [J

line 190: func! s:FTasmsyntax()[J

line 202: [J

line 203: " Macro (VAX)[J

line 204: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm[J

line 205: [J

line 206: " Atlas[J

line 207: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas[J

line 208: [J

line 209: " Autoit v3[J

line 210: au BufNewFile,BufRead *.au3^I^I^Isetf autoit[J

line 211: [J

line 212: " Autohotkey[J

line 213: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey[J

line 214: [J

line 215: " Automake[J

line 216: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake[J

line 217: [J

line 218: " Autotest .at files are actually m4[J

line 219: au BufNewFile,BufRead *.at^I^I^Isetf m4[J

line 220: [J

line 221: " Avenue[J

line 222: au BufNewFile,BufRead *.ave^I^I^Isetf ave[J

line 223: [J

line 224: " Awk[J

line 225: au BufNewFile,BufRead *.awk^I^I^Isetf awk[J

line 226: [J

line 227: " B[J

line 228: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b[J

line 229: [J

line 230: " BASIC or Visual Basic[J

line 231: au BufNewFile,BufRead *.bas^I^I^Icall s:FTVB("basic")[J

line 232: [J

line 233: " Check if one of the first five lines contains "VB_Name".  In that case it is[J

line 234: " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.[J

line 235: func! s:FTVB(alt)[J

line 242: [J

line 243: " Visual Basic Script (close to Visual Basic)[J

line 244: au BufNewFile,BufRead *.vbs,*.dsm,*.ctl^I^Isetf vb[J

line 245: [J

line 246: " IBasic file (similar to QBasic)[J

line 247: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic[J

line 248: [J

line 249: " FreeBasic file (similar to QBasic)[J

line 250: au BufNewFile,BufRead *.fb,*.bi^I^I^Isetf freebasic[J

line 251: [J

line 252: " Batch file for MSDOS.[J

line 253: au BufNewFile,BufRead *.bat,*.sys^I^Isetf dosbatch[J

line 254: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.[J

line 256: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif[J

line 257: [J

line 258: " Batch file for 4DOS[J

line 259: au BufNewFile,BufRead *.btm^I^I^Icall s:FTbtm()[J

line 260: func! s:FTbtm()[J

line 267: [J

line 268: " BC calculator[J

line 269: au BufNewFile,BufRead *.bc^I^I^Isetf bc[J

line 270: [J

line 271: " BDF font[J

line 272: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf[J

line 273: [J

line 274: " BibTeX bibliography database file[J

line 275: au BufNewFile,BufRead *.bib^I^I^Isetf bib[J

line 276: [J

line 277: " BibTeX Bibliography Style[J

line 278: au BufNewFile,BufRead *.bst^I^I^Isetf bst[J

line 279: [J

line 280: " BIND configuration[J

line 281: au BufNewFile,BufRead named.conf,rndc.conf^Isetf named[J

line 282: [J

line 283: " BIND zone[J

line 284: au BufNewFile,BufRead named.root^I^Isetf bindzone[J

line 285: au BufNewFile,BufRead *.db^I^I^Icall s:BindzoneCheck('')[J

line 286: [J

line 287: func! s:BindzoneCheck(default)[J

line 294: [J

line 295: " Blank[J

line 296: au BufNewFile,BufRead *.bl^I^I^Isetf blank[J

line 297: [J

line 298: " Blkid cache file[J

line 299: au BufNewFile,BufRead /etc/blkid.tab,/etc/blkid.tab.old   setf xml[J

line 300: [J

line 301: " C or lpc[J

line 302: au BufNewFile,BufRead *.c^I^I^Icall s:FTlpc()[J

line 303: [J

line 304: func! s:FTlpc()[J

line 317: [J

line 318: " Calendar[J

line 319: au BufNewFile,BufRead calendar^I^I^Isetf calendar[J

line 322: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')[J

line 323: [J

line 324: " C#[J

line 325: au BufNewFile,BufRead *.cs^I^I^Isetf cs[J

line 326: [J

line 327: " Cabal[J

line 328: au BufNewFile,BufRead *.cabal       ^I^Isetf cabal[J

line 329: [J

line 330: " Cdrdao TOC[J

line 331: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc[J

line 332: [J

line 333: " Cdrdao config[J

line 334: au BufNewFile,BufRead etc/cdrdao.conf,etc/defaults/cdrdao,etc/default/cdrdao,~/.cdrdao^I^I^I^I^I^Isetf cdrdaoconf[J

line 335: [J

line 336: " Cfengine[J

line 337: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine[J

line 338: [J

line 339: " ChaiScript[J

line 340: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript[J

line 341: [J

line 342: " Comshare Dimension Definition Language[J

line 343: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl[J

line 344: [J

line 345: " Conary Recipe[J

line 346: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe[J

line 347: [J

line 348: " Controllable Regex Mutilator[J

line 349: au BufNewFile,BufRead *.crm^I^I^Isetf crm[J

line 350: [J

line 351: " Cyn++[J

line 352: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp[J

line 353: [J

line 354: " Cynlib[J

line 355: " .cc and .cpp files can be C++ or Cynlib.[J

line 357: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif[J

line 359: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif[J

line 360: [J

line 361: " C++[J

line 362: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp[J

line 363: if has("fname_case")[J

line 364:   au BufNewFile,BufRead *.C,*.H setf cpp[J

line 365: endif[J

line 366: [J

line 367: " .h files can be C, Ch C++, ObjC or ObjC++.[J

line 368: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is[J

line 369: " detected automatically.[J

line 370: au BufNewFile,BufRead *.h^I^I^Icall s:FTheader()[J

line 371: [J

line 372: func! s:FTheader()[J

line 383: [J

line 384: " Ch (CHscript)[J

line 385: au BufNewFile,BufRead *.chf^I^I^Isetf ch[J

line 386: [J

line 387: " TLH files are C++ headers generated by Visual C++'s #import from typelibs[J

line 388: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp[J

line 389: [J

line 390: " Cascading Style Sheets[J

line 391: au BufNewFile,BufRead *.css^I^I^Isetf css[J

line 392: [J

line 393: " Century Term Command Scripts (*.cmd too)[J

line 394: au BufNewFile,BufRead *.con^I^I^Isetf cterm[J

line 395: [J

line 396: " Changelog[J

line 398: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch^Isetf debchangelog[J

line 399: [J

line 405: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif[J

line 406: [J

line 410: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif[J

line 411: [J

line 412: " CHILL[J

line 413: au BufNewFile,BufRead *..ch^I^I^Isetf chill[J

line 414: [J

line 415: " Changes for WEB and CWEB or CHILL[J

line 416: au BufNewFile,BufRead *.ch^I^I^Icall s:FTchange()[J

line 417: [J

line 418: " This function checks if one of the first ten lines start with a '@'.  In[J

line 419: " that case it is probably a change file.[J

line 420: " If the first line starts with # or ! it's probably a ch file.[J

line 421: " If a line has "main", "include", "//" ir "/*" it's probably ch.[J

line 422: " Otherwise CHILL is assumed.[J

line 423: func! s:FTchange()[J

line 446: [J

line 447: " ChordPro[J

line 448: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro[J

line 449: [J

line 450: " Clean[J

line 451: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean[J

line 452: [J

line 453: " Clever[J

line 454: au BufNewFile,BufRead *.eni^I^I^Isetf cl[J

line 455: [J

line 456: " Clever or dtd[J

line 457: au BufNewFile,BufRead *.ent^I^I^Icall s:FTent()[J

line 458: [J

line 459: func! s:FTent()[J

line 478: [J

line 479: " Clipper (or FoxPro; could also be eviews)[J

line 485: au BufNewFile,BufRead *.prg if exists("g:filetype_prg") |   exe "setf " . g:filetype_prg | else |   setf clipper | endif[J

line 486: [J

line 487: " Cmake[J

line 488: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake[J

line 489: [J

line 490: " Cmusrc[J

line 491: au BufNewFile,BufRead ~/.cmus/{autosave,rc,command-history,*.theme} setf cmusrc[J

line 492: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc[J

line 493: [J

line 494: " Cobol[J

line 495: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol[J

line 496: "   cobol or zope form controller python script? (heuristic)[J

line 502: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif[J

line 503: [J

line 504: " Coco/R[J

line 505: au BufNewFile,BufRead *.atg^I^I^Isetf coco[J

line 506: [J

line 507: " Cold Fusion[J

line 508: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf[J

line 509: [J

line 510: " Configure scripts[J

line 511: au BufNewFile,BufRead configure.in,configure.ac setf config[J

line 512: [J

line 513: " CUDA  Cumpute Unified Device Architecture[J

line 514: au BufNewFile,BufRead *.cu^I^I^Isetf cuda[J

line 515: [J

line 516: " WildPackets EtherPeek Decoder[J

line 517: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd[J

line 518: [J

line 519: " Enlightenment configuration files[J

line 520: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c[J

line 521: [J

line 522: " Eterm[J

line 523: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm[J

line 524: [J

line 525: " Lynx config files[J

line 526: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx[J

line 527: [J

line 528: " Quake[J

line 529: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake[J

line 530: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake[J

line 531: [J

line 532: " Quake C[J

line 533: au BufNewFile,BufRead *.qc^I^I^Isetf c[J

line 534: [J

line 535: " Configure files[J

line 536: au BufNewFile,BufRead *.cfg^I^I^Isetf cfg[J

line 537: [J

line 538: " Cucumber[J

line 539: au BufNewFile,BufRead *.feature ^I^Isetf cucumber[J

line 540: [J

line 541: " Communicating Sequential Processes[J

line 542: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp[J

line 543: [J

line 544: " CUPL logic description and simulation[J

line 545: au BufNewFile,BufRead *.pld^I^I^Isetf cupl[J

line 546: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim[J

line 547: [J

line 548: " Debian Control[J

line 549: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol[J

line 553: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif[J

line 554: [J

line 555: " Debian Sources.list[J

line 556: au BufNewFile,BufRead /etc/apt/sources.list^Isetf debsources[J

line 557: [J

line 558: " Deny hosts[J

line 559: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts[J

line 560: [J

line 561: " ROCKLinux package description[J

line 562: au BufNewFile,BufRead *.desc^I^I^Isetf desc[J

line 563: [J

line 564: " the D language or dtrace[J

line 565: au BufNewFile,BufRead *.d^I^I^Icall s:DtraceCheck()[J

line 566: [J

line 567: func! s:DtraceCheck()[J

line 575: [J

line 576: " Desktop files[J

line 577: au BufNewFile,BufRead *.desktop,.directory^Isetf desktop[J

line 578: [J

line 579: " Dict config[J

line 580: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf[J

line 581: [J

line 582: " Dictd config[J

line 583: au BufNewFile,BufRead dictd.conf^I^Isetf dictdconf[J

line 584: [J

line 585: " Diff files[J

line 586: au BufNewFile,BufRead *.diff,*.rej,*.patch^Isetf diff[J

line 587: [J

line 588: " Dircolors[J

line 589: au BufNewFile,BufRead .dir_colors,/etc/DIR_COLORS^Isetf dircolors[J

line 590: [J

line 591: " Diva (with Skill) or InstallShield[J

line 597: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif[J

line 598: [J

line 599: " DCL (Digital Command Language - vms) or DNS zone file[J

line 600: au BufNewFile,BufRead *.com^I^I^Icall s:BindzoneCheck('dcl')[J

line 601: [J

line 602: " DOT[J

line 603: au BufNewFile,BufRead *.dot^I^I^Isetf dot[J

line 604: [J

line 605: " Dylan - lid files[J

line 606: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid[J

line 607: [J

line 608: " Dylan - intr files (melange)[J

line 609: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr[J

line 610: [J

line 611: " Dylan[J

line 612: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan[J

line 613: [J

line 614: " Microsoft Module Definition[J

line 615: au BufNewFile,BufRead *.def^I^I^Isetf def[J

line 616: [J

line 617: " Dracula[J

line 618: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula[J

line 619: [J

line 620: " Datascript[J

line 621: au BufNewFile,BufRead *.ds^I^I^Isetf datascript[J

line 622: [J

line 623: " dsl[J

line 624: au BufNewFile,BufRead *.dsl^I^I^Isetf dsl[J

line 625: [J

line 626: " DTD (Document Type Definition for XML)[J

line 627: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd[J

line 628: [J

line 629: " EDIF (*.edf,*.edif,*.edn,*.edo)[J

line 630: au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)^Isetf edif[J

line 631: [J

line 632: " Embedix Component Description[J

line 633: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd[J

line 634: [J

line 635: " Eiffel or Specman[J

line 636: au BufNewFile,BufRead *.e,*.E^I^I^Icall s:FTe()[J

line 637: [J

line 638: " Elinks configuration[J

line 639: au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf^Isetf elinks[J

line 640: [J

line 641: func! s:FTe()[J

line 652: [J

line 653: " ERicsson LANGuage; Yaws is erlang too[J

line 654: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang[J

line 655: [J

line 656: " Elm Filter Rules file[J

line 657: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt[J

line 658: [J

line 659: " ESMTP rc file[J

line 660: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc[J

line 661: [J

line 662: " ESQL-C[J

line 663: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc[J

line 664: [J

line 665: " Esterel[J

line 666: au BufNewFile,BufRead *.strl^I^I^Isetf esterel[J

line 667: [J

line 668: " Essbase script[J

line 669: au BufNewFile,BufRead *.csc^I^I^Isetf csc[J

line 670: [J

line 671: " Exim[J

line 672: au BufNewFile,BufRead exim.conf^I^I^Isetf exim[J

line 673: [J

line 674: " Expect[J

line 675: au BufNewFile,BufRead *.exp^I^I^Isetf expect[J

line 676: [J

line 677: " Exports[J

line 678: au BufNewFile,BufRead exports^I^I^Isetf exports[J

line 679: [J

line 680: " Fantom[J

line 681: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan[J

line 682: [J

line 683: " Factor[J

line 684: au BufNewFile,BufRead *.factor^I^I^Isetf factor[J

line 685: [J

line 686: " Fetchmail RC file[J

line 687: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail[J

line 688: [J

line 689: " FlexWiki - disabled, because it has side effects when a .wiki file[J

line 690: " is not actually FlexWiki[J

line 691: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki[J

line 692: [J

line 693: " Focus Executable[J

line 694: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec[J

line 695: [J

line 696: " Focus Master file (but not for auto.master)[J

line 697: au BufNewFile,BufRead auto.master^I^Isetf conf[J

line 698: au BufNewFile,BufRead *.mas,*.master^I^Isetf master[J

line 699: [J

line 700: " Forth[J

line 701: au BufNewFile,BufRead *.fs,*.ft^I^I^Isetf forth[J

line 702: [J

line 703: " Reva Forth[J

line 704: au BufNewFile,BufRead *.frt^I^I^Isetf reva[J

line 705: [J

line 706: " Fortran[J

line 707: if has("fname_case")[J

line 708:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^I setf fortran[J

line 709: endif[J

line 710: au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran[J

line 711: [J

line 712: " Framescript[J

line 713: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript[J

line 714: [J

line 715: " FStab[J

line 716: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab[J

line 717: [J

line 718: " GDB command files[J

line 719: au BufNewFile,BufRead .gdbinit^I^I^Isetf gdb[J

line 720: [J

line 721: " GDMO[J

line 722: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo[J

line 723: [J

line 724: " Gedcom[J

line 725: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom[J

line 726: [J

line 727: " Git[J

line 728: autocmd BufNewFile,BufRead *.git/COMMIT_EDITMSG setf gitcommit[J

line 729: autocmd BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig[J

line 730: autocmd BufNewFile,BufRead git-rebase-todo      setf gitrebase[J

line 734: autocmd BufNewFile,BufRead .msg.[0-9]* if getline(1) =~ '^From.*# This line is ignored.$' |   setf gitsendemail | endif[J

line 738: autocmd BufNewFile,BufRead *.git/** if getline(1) =~ '^\x\{40\}\>\|^ref: ' |   setf git | endif[J

line 739: [J

line 740: " Gkrellmrc[J

line 741: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc[J

line 742: [J

line 743: " GP scripts (2.0 and onward)[J

line 744: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp[J

line 745: [J

line 746: " GPG[J

line 747: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg[J

line 748: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg[J

line 749: au BufNewFile,BufRead /usr/**/gnupg/options.skel setf gpg[J

line 750: [J

line 751: " Gnuplot scripts[J

line 752: au BufNewFile,BufRead *.gpi^I^I^Isetf gnuplot[J

line 753: [J

line 754: " GrADS scripts[J

line 755: au BufNewFile,BufRead *.gs^I^I^Isetf grads[J

line 756: [J

line 757: " Gretl[J

line 758: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl[J

line 759: [J

line 760: " Groovy[J

line 761: au BufNewFile,BufRead *.groovy^I^I^Isetf groovy[J

line 762: [J

line 763: " GNU Server Pages[J

line 764: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp[J

line 765: [J

line 766: " Group file[J

line 767: au BufNewFile,BufRead /etc/group,/etc/group-,/etc/group.edit,/etc/gshadow,/etc/gshadow-,/etc/gshadow.edit,/var/backups/group.bak,/var/backups/gshadow.bak  setf group[J

line 768: [J

line 769: " GTK RC[J

line 770: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc[J

line 771: [J

line 772: " Haml[J

line 773: au BufNewFile,BufRead *.haml^I^I^Isetf haml[J

line 774: [J

line 775: " Hamster Classic | Playground files[J

line 776: au BufNewFile,BufRead *.hsc,*.hsm^I^Isetf hamster[J

line 777: [J

line 778: " Haskell[J

line 779: au BufNewFile,BufRead *.hs,*.hs-boot ^I^Isetf haskell[J

line 780: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell[J

line 781: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell[J

line 782: [J

line 783: " Haste[J

line 784: au BufNewFile,BufRead *.ht^I^I^Isetf haste[J

line 785: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc[J

line 786: [J

line 787: " Hercules[J

line 788: au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum^Isetf hercules[J

line 789: [J

line 790: " HEX (Intel)[J

line 791: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex[J

line 792: [J

line 793: " Tilde (must be before HTML)[J

line 794: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde[J

line 795: [J

line 796: " HTML (.shtml and .stm for server side)[J

line 797: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()[J

line 798: [J

line 799: " Distinguish between HTML, XHTML and Django[J

line 800: func! s:FThtml()[J

line 815: [J

line 816: " HTML with Ruby - eRuby[J

line 817: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby[J

line 818: [J

line 819: " HTML with M4[J

line 820: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4[J

line 821: [J

line 822: " HTML Cheetah template[J

line 823: au BufNewFile,BufRead *.tmpl^I^I^Isetf htmlcheetah[J

line 824: [J

line 825: " Host config[J

line 826: au BufNewFile,BufRead /etc/host.conf^I^Isetf hostconf[J

line 827: [J

line 828: " Hosts access[J

line 829: au BufNewFile,BufRead /etc/hosts.allow,/etc/hosts.deny  setf hostsaccess[J

line 830: [J

line 831: " Hyper Builder[J

line 832: au BufNewFile,BufRead *.hb^I^I^Isetf hb[J

line 833: [J

line 834: " Icon[J

line 835: au BufNewFile,BufRead *.icn^I^I^Isetf icon[J

line 836: [J

line 837: " IDL (Interface Description Language)[J

line 838: au BufNewFile,BufRead *.idl^I^I^Icall s:FTidl()[J

line 839: [J

line 840: " Distinguish between standard IDL and MS-IDL[J

line 841: func! s:FTidl()[J

line 852: [J

line 853: " Microsoft IDL (Interface Description Language)  Also *.idl[J

line 854: " MOF = WMI (Windows Management Instrumentation) Managed Object Format[J

line 855: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl[J

line 856: [J

line 857: " Icewm menu[J

line 858: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu[J

line 859: [J

line 860: " Indent profile (must come before IDL *.pro!)[J

line 861: au BufNewFile,BufRead .indent.pro^I^Isetf indent[J

line 862: au BufNewFile,BufRead indent.pro^I^Icall s:ProtoCheck('indent')[J

line 863: [J

line 864: " IDL (Interactive Data Language)[J

line 865: au BufNewFile,BufRead *.pro^I^I^Icall s:ProtoCheck('idlang')[J

line 866: [J

line 867: " Distinguish between "default" and Cproto prototype file. */[J

line 868: func! s:ProtoCheck(default)[J

line 878: [J

line 879: [J

line 880: " Indent RC[J

line 881: au BufNewFile,BufRead indentrc^I^I^Isetf indent[J

line 882: [J

line 883: " Inform[J

line 884: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform[J

line 885: [J

line 886: " Initng[J

line 887: au BufNewFile,BufRead /etc/initng/**/*.i,*.ii^Isetf initng[J

line 888: [J

line 889: " Ipfilter[J

line 890: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter[J

line 891: [J

line 892: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)[J

line 893: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl[J

line 894: [J

line 895: " .INI file for MSDOS[J

line 896: au BufNewFile,BufRead *.ini^I^I^Isetf dosini[J

line 897: [J

line 898: " SysV Inittab[J

line 899: au BufNewFile,BufRead inittab^I^I^Isetf inittab[J

line 900: [J

line 901: " Inno Setup[J

line 902: au BufNewFile,BufRead *.iss^I^I^Isetf iss[J

line 903: [J

line 904: " JAL[J

line 905: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal[J

line 906: [J

line 907: " Jam[J

line 908: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam[J

line 909: [J

line 910: " Java[J

line 911: au BufNewFile,BufRead *.java,*.jav^I^Isetf java[J

line 912: [J

line 913: " JavaCC[J

line 914: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc[J

line 915: [J

line 916: " JavaScript, ECMAScript[J

line 917: au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx^Isetf javascript[J

line 918: [J

line 919: " Java Server Pages[J

line 920: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp[J

line 921: [J

line 922: " Java Properties resource file (note: doesn't catch font.properties.pl)[J

line 923: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties[J

line 924: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')[J

line 925: [J

line 926: " Jess[J

line 927: au BufNewFile,BufRead *.clp^I^I^Isetf jess[J

line 928: [J

line 929: " Jgraph[J

line 930: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph[J

line 931: [J

line 932: " Kixtart[J

line 933: au BufNewFile,BufRead *.kix^I^I^Isetf kix[J

line 934: [J

line 935: " Kimwitu[++][J

line 936: au BufNewFile,BufRead *.k^I^I^Isetf kwt[J

line 937: [J

line 938: " KDE script[J

line 939: au BufNewFile,BufRead *.ks^I^I^Isetf kscript[J

line 940: [J

line 941: " Kconfig[J

line 942: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig[J

line 943: [J

line 944: " Lace (ISE)[J

line 945: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace[J

line 946: [J

line 947: " Latte[J

line 948: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte[J

line 949: [J

line 950: " Limits[J

line 951: au BufNewFile,BufRead /etc/limits^I^Isetf limits[J

line 952: [J

line 953: " LambdaProlog (*.mod too, see Modsim)[J

line 954: au BufNewFile,BufRead *.sig^I^I^Isetf lprolog[J

line 955: [J

line 956: " LDAP LDIF[J

line 957: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif[J

line 958: [J

line 959: " Ld loader[J

line 960: au BufNewFile,BufRead *.ld^I^I^Isetf ld[J

line 961: [J

line 962: " Lex[J

line 963: au BufNewFile,BufRead *.lex,*.l^I^I^Isetf lex[J

line 964: [J

line 965: " Libao[J

line 966: au BufNewFile,BufRead /etc/libao.conf,*/.libao^Isetf libao[J

line 967: [J

line 968: " Libsensors[J

line 969: au BufNewFile,BufRead /etc/sensors.conf^I^Isetf sensors[J

line 970: [J

line 971: " LFTP[J

line 972: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp[J

line 973: [J

line 974: " Lifelines (or Lex for C++!)[J

line 975: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines[J

line 976: [J

line 977: " Lilo: Linux loader[J

line 978: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')[J

line 979: [J

line 980: " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)[J

line 981: if has("fname_case")[J

line 982:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp[J

line 983: else[J

line 984:   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp[J

line 985: endif[J

line 986: [J

line 987: " SBCL implementation of Common Lisp[J

line 988: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp[J

line 989: [J

line 990: " Liquid[J

line 991: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid[J

line 992: [J

line 993: " Lite[J

line 994: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite[J

line 995: [J

line 996: " LiteStep RC files[J

line 997: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep[J

line 998: [J

line 999: " Login access[J

line 1000: au BufNewFile,BufRead /etc/login.access^I^Isetf loginaccess[J

line 1001: [J

line 1002: " Login defs[J

line 1003: au BufNewFile,BufRead /etc/login.defs^I^Isetf logindefs[J

line 1004: [J

line 1005: " Logtalk[J

line 1006: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk[J

line 1007: [J

line 1008: " LOTOS[J

line 1009: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos[J

line 1010: [J

line 1011: " Lout (also: *.lt)[J

line 1012: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout[J

line 1013: [J

line 1014: " Lua[J

line 1015: au BufNewFile,BufRead *.lua^I^I^Isetf lua[J

line 1016: [J

line 1017: " Linden Scripting Language (Second Life)[J

line 1018: au BufNewFile,BufRead *.lsl^I^I^Isetf lsl[J

line 1019: [J

line 1020: " Lynx style file (or LotusScript!)[J

line 1021: au BufNewFile,BufRead *.lss^I^I^Isetf lss[J

line 1022: [J

line 1023: " M4[J

line 1025: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif[J

line 1026: [J

line 1027: " MaGic Point[J

line 1028: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp[J

line 1029: [J

line 1030: " Mail (for Elm, trn, mutt, muttng, rn, slrn)[J

line 1031: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail[J

line 1032: [J

line 1033: " Mail aliases[J

line 1034: au BufNewFile,BufRead /etc/mail/aliases,/etc/aliases^Isetf mailaliases[J

line 1035: [J

line 1036: " Mailcap configuration file[J

line 1037: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap[J

line 1038: [J

line 1039: " Makefile[J

line 1040: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make[J

line 1041: [J

line 1042: " MakeIndex[J

line 1043: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist[J

line 1044: [J

line 1045: " Manpage[J

line 1046: au BufNewFile,BufRead *.man^I^I^Isetf man[J

line 1047: [J

line 1048: " Man config[J

line 1049: au BufNewFile,BufRead /etc/man.conf,man.config^Isetf manconf[J

line 1050: [J

line 1051: " Maple V[J

line 1052: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple[J

line 1053: [J

line 1054: " Map (UMN mapserver config file)[J

line 1055: au BufNewFile,BufRead *.map^I^I^Isetf map[J

line 1056: [J

line 1057: " Markdown[J

line 1058: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,README.md  setf markdown[J

line 1059: [J

line 1060: " Mason[J

line 1061: au BufNewFile,BufRead *.mason,*.mhtml^I^Isetf mason[J

line 1062: [J

line 1063: " Matlab or Objective C[J

line 1064: au BufNewFile,BufRead *.m^I^I^Icall s:FTm()[J

line 1065: [J

line 1066: func! s:FTm()[J

line 1090: [J

line 1091: " Mathematica notebook[J

line 1092: au BufNewFile,BufRead *.nb^I^I^Isetf mma[J

line 1093: [J

line 1094: " Maya Extension Language[J

line 1095: au BufNewFile,BufRead *.mel^I^I^Isetf mel[J

line 1096: [J

line 1097: " Mercurial config (looks like generic config file)[J

line 1098: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg[J

line 1099: [J

line 1100: " Messages[J

line 1101: au BufNewFile,BufRead /var/log/messages,/var/log/messages.*[0-9]  setf messages[J

line 1102: [J

line 1103: " Metafont[J

line 1104: au BufNewFile,BufRead *.mf^I^I^Isetf mf[J

line 1105: [J

line 1106: " MetaPost[J

line 1107: au BufNewFile,BufRead *.mp^I^I^Isetf mp[J

line 1108: [J

line 1109: " MGL[J

line 1110: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl[J

line 1111: [J

line 1112: " MMIX or VMS makefile[J

line 1113: au BufNewFile,BufRead *.mms^I^I^Icall s:FTmms()[J

line 1114: [J

line 1115: " Symbian meta-makefile definition (MMP)[J

line 1116: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp[J

line 1117: [J

line 1118: func! s:FTmms()[J

line 1134: [J

line 1135: [J

line 1136: " Modsim III (or LambdaProlog)[J

line 1142: au BufNewFile,BufRead *.mod if getline(1) =~ '\<module\>' |   setf lprolog | else |   setf modsim3 | endif[J

line 1143: [J

line 1144: " Modula 2[J

line 1145: au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.md,*.mi setf modula2[J

line 1146: [J

line 1147: " Modula 3 (.m3, .i3, .mg, .ig)[J

line 1148: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3[J

line 1149: [J

line 1150: " Monk[J

line 1151: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk[J

line 1152: [J

line 1153: " MOO[J

line 1154: au BufNewFile,BufRead *.moo^I^I^Isetf moo[J

line 1155: [J

line 1156: " Modconf[J

line 1157: au BufNewFile,BufRead /etc/modules.conf,/etc/conf.modules^Isetf modconf[J

line 1161: au BufNewFile,BufRead /etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif[J

line 1162: [J

line 1163: " Mplayer config[J

line 1164: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf[J

line 1165: [J

line 1166: " Moterola S record[J

line 1167: au BufNewFile,BufRead *.s19,*.s28,*.s37^I^Isetf srec[J

line 1168: [J

line 1169: " Mrxvtrc[J

line 1170: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc[J

line 1171: [J

line 1172: " Msql[J

line 1173: au BufNewFile,BufRead *.msql^I^I^Isetf msql[J

line 1174: [J

line 1175: " Mysql[J

line 1176: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql[J

line 1177: [J

line 1178: " M$ Resource files[J

line 1179: au BufNewFile,BufRead *.rc^I^I^Isetf rc[J

line 1180: [J

line 1181: " MuPAD source[J

line 1182: au BufRead,BufNewFile *.mu^I^I^Isetf mupad[J

line 1183: [J

line 1184: " Mush[J

line 1185: au BufNewFile,BufRead *.mush^I^I^Isetf mush[J

line 1186: [J

line 1187: " Mutt setup file (also for Muttng)[J

line 1188: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc[J

line 1189: [J

line 1190: " Nano[J

line 1191: au BufNewFile,BufRead /etc/nanorc,.nanorc^Isetf nanorc[J

line 1192: [J

line 1193: " Nastran input/DMAP[J

line 1194: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran[J

line 1195: [J

line 1196: " Natural[J

line 1197: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural[J

line 1198: [J

line 1199: " Netrc[J

line 1200: au BufNewFile,BufRead .netrc^I^I^Isetf netrc[J

line 1201: [J

line 1202: " Novell netware batch files[J

line 1203: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf[J

line 1204: [J

line 1205: " Nroff/Troff (*.ms and *.t are checked below)[J

line 1209: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif[J

line 1210: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff[J

line 1211: au BufNewFile,BufRead *.[1-9]^I^I^Icall s:FTnroff()[J

line 1212: [J

line 1213: " This function checks if one of the first five lines start with a dot.  In[J

line 1214: " that case it is probably an nroff file: 'filetype' is set and 1 is returned.[J

line 1215: func! s:FTnroff()[J

line 1222: [J

line 1223: " Nroff or Objective C++[J

line 1224: au BufNewFile,BufRead *.mm^I^I^Icall s:FTmm()[J

line 1225: [J

line 1226: func! s:FTmm()[J

line 1238: [J

line 1239: " Not Quite C[J

line 1240: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc[J

line 1241: [J

line 1242: " NSIS[J

line 1243: au BufNewFile,BufRead *.nsi^I^I^Isetf nsis[J

line 1244: [J

line 1245: " OCAML[J

line 1246: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly^Isetf ocaml[J

line 1247: [J

line 1248: " Occam[J

line 1249: au BufNewFile,BufRead *.occ^I^I^Isetf occam[J

line 1250: [J

line 1251: " Omnimark[J

line 1252: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark[J

line 1253: [J

line 1254: " OpenROAD[J

line 1255: au BufNewFile,BufRead *.or^I^I^Isetf openroad[J

line 1256: [J

line 1257: " OPL[J

line 1258: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^Isetf opl[J

line 1259: [J

line 1260: " Oracle config file[J

line 1261: au BufNewFile,BufRead *.ora^I^I^Isetf ora[J

line 1262: [J

line 1263: " Packet filter conf[J

line 1264: au BufNewFile,BufRead pf.conf^I^I^Isetf pf[J

line 1265: [J

line 1266: " Pam conf[J

line 1267: au BufNewFile,BufRead /etc/pam.conf^I^Isetf pamconf[J

line 1268: [J

line 1269: " PApp[J

line 1270: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^Isetf papp[J

line 1271: [J

line 1272: " Password file[J

line 1273: au BufNewFile,BufRead /etc/passwd,/etc/passwd-,/etc/passwd.edit,/etc/shadow,/etc/shadow-,/var/backups/passwd.bak,/var/backups/shadow.bak setf passwd[J

line 1274: [J

line 1275: " Pascal (also *.p)[J

line 1276: au BufNewFile,BufRead *.pas^I^I^Isetf pascal[J

line 1277: [J

line 1278: " Delphi project file[J

line 1279: au BufNewFile,BufRead *.dpr^I^I^Isetf pascal[J

line 1280: [J

line 1281: " PDF[J

line 1282: au BufNewFile,BufRead *.pdf^I^I^Isetf pdf[J

line 1283: [J

line 1284: " Perl[J

line 1285: if has("fname_case")[J

line 1286:   au BufNewFile,BufRead *.pl,*.PL^I^Icall s:FTpl()[J

line 1287: else[J

line 1288:   au BufNewFile,BufRead *.pl^I^I^Icall s:FTpl()[J

line 1289: endif[J

line 1290: au BufNewFile,BufRead *.plx,*.al^I^Isetf perl[J

line 1291: au BufNewFile,BufRead *.p6,*.pm6^I^Isetf perl6[J

line 1292: [J

line 1293: func! s:FTpl()[J

line 1307: [J

line 1308: " Perl, XPM or XPM2[J

line 1316: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif[J

line 1317: [J

line 1318: " Perl POD[J

line 1319: au BufNewFile,BufRead *.pod^I^I^Isetf pod[J

line 1320: [J

line 1321: " Php, php3, php4, etc.[J

line 1322: " Also Phtml (was used for PHP 2 in the past)[J

line 1323: " Also .ctp for Cake template file[J

line 1324: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp^Isetf php[J

line 1325: [J

line 1326: " Pike[J

line 1327: au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike[J

line 1328: [J

line 1329: " Pinfo config[J

line 1330: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo[J

line 1331: [J

line 1332: " Palm Resource compiler[J

line 1333: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc[J

line 1334: [J

line 1335: " Pine config[J

line 1336: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine[J

line 1337: [J

line 1338: " PL/M (also: *.inp)[J

line 1339: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm[J

line 1340: [J

line 1341: " PL/SQL[J

line 1342: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql[J

line 1343: [J

line 1344: " PLP[J

line 1345: au BufNewFile,BufRead *.plp^I^I^Isetf plp[J

line 1346: [J

line 1347: " PO and PO template (GNU gettext)[J

line 1348: au BufNewFile,BufRead *.po,*.pot^I^Isetf po[J

line 1349: [J

line 1350: " Postfix main config[J

line 1351: au BufNewFile,BufRead main.cf^I^I^Isetf pfmain[J

line 1352: [J

line 1353: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)[J

line 1354: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr[J

line 1355: [J

line 1356: " PostScript Printer Description[J

line 1357: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd[J

line 1358: [J

line 1359: " Povray[J

line 1360: au BufNewFile,BufRead *.pov^I^I^Isetf pov[J

line 1361: [J

line 1362: " Povray configuration[J

line 1363: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini[J

line 1364: [J

line 1365: " Povray, PHP or assembly[J

line 1366: au BufNewFile,BufRead *.inc^I^I^Icall s:FTinc()[J

line 1367: [J

line 1368: func! s:FTinc()[J

line 1389: [J

line 1390: " Printcap and Termcap[J

line 1392: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap[J

line 1394: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap[J

line 1395: [J

line 1396: " PCCTS / ANTRL[J

line 1397: "au BufNewFile,BufRead *.g^I^I^Isetf antrl[J

line 1398: au BufNewFile,BufRead *.g^I^I^Isetf pccts[J

line 1399: [J

line 1400: " PPWizard[J

line 1401: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz[J

line 1402: [J

line 1403: " Obj 3D file format[J

line 1404: " TODO: is there a way to avoid MS-Windows Object files?[J

line 1405: au BufNewFile,BufRead *.obj         ^I^Isetf obj[J

line 1406: [J

line 1407: " Oracle Pro*C/C++[J

line 1408: au BufNewFile,BufRead *.pc^I^I^Isetf proc[J

line 1409: [J

line 1410: " Privoxy actions file[J

line 1411: au BufNewFile,BufRead *.action^I^I^Isetf privoxy[J

line 1412: [J

line 1413: " Procmail[J

line 1414: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail[J

line 1415: [J

line 1416: " Progress or CWEB[J

line 1417: au BufNewFile,BufRead *.w^I^I^Icall s:FTprogress_cweb()[J

line 1418: [J

line 1419: func! s:FTprogress_cweb()[J

line 1430: [J

line 1431: " Progress or assembly[J

line 1432: au BufNewFile,BufRead *.i^I^I^Icall s:FTprogress_asm()[J

line 1433: [J

line 1434: func! s:FTprogress_asm()[J

line 1456: [J

line 1457: " Progress or Pascal[J

line 1458: au BufNewFile,BufRead *.p^I^I^Icall s:FTprogress_pascal()[J

line 1459: [J

line 1460: func! s:FTprogress_pascal()[J

line 1484: [J

line 1485: [J

line 1486: " Software Distributor Product Specification File (POSIX 1387.2-1995)[J

line 1487: au BufNewFile,BufRead *.psf^I^I^Isetf psf[J

line 1491: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif[J

line 1492: [J

line 1493: " Prolog[J

line 1494: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog[J

line 1495: [J

line 1496: " Promela[J

line 1497: au BufNewFile,BufRead *.pml^I^I^Isetf promela[J

line 1498: [J

line 1499: " Protocols[J

line 1500: au BufNewFile,BufRead /etc/protocols^I^Isetf protocols[J

line 1501: [J

line 1502: " Pyrex[J

line 1503: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex[J

line 1504: [J

line 1505: " Python[J

line 1506: au BufNewFile,BufRead *.py,*.pyw^I^Isetf python[J

line 1507: [J

line 1508: " Quixote (Python-based web framework)[J

line 1509: au BufNewFile,BufRead *.ptl^I^I^Isetf python[J

line 1510: [J

line 1511: " Radiance[J

line 1512: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance[J

line 1513: [J

line 1514: " Ratpoison config/command files[J

line 1515: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison[J

line 1516: [J

line 1517: " RCS file[J

line 1518: au BufNewFile,BufRead *\,v^I^I^Isetf rcs[J

line 1519: [J

line 1520: " Readline[J

line 1521: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline[J

line 1522: [J

line 1523: " Registry for MS-Windows[J

line 1525: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif[J

line 1526: [J

line 1527: " Renderman Interface Bytestream[J

line 1528: au BufNewFile,BufRead *.rib^I^I^Isetf rib[J

line 1529: [J

line 1530: " Rexx[J

line 1531: au BufNewFile,BufRead *.rexx,*.rex,*.jrexx,*.rxj,*.orx^Isetf rexx[J

line 1532: [J

line 1533: " R (Splus)[J

line 1534: if has("fname_case")[J

line 1535:   au BufNewFile,BufRead *.s,*.S^I^I^Isetf r[J

line 1536: else[J

line 1537:   au BufNewFile,BufRead *.s^I^I^Isetf r[J

line 1538: endif[J

line 1539: [J

line 1540: " R Help file[J

line 1541: if has("fname_case")[J

line 1542:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp[J

line 1543: else[J

line 1544:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp[J

line 1545: endif[J

line 1546: [J

line 1547: " R noweb file[J

line 1548: if has("fname_case")[J

line 1549:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb[J

line 1550: else[J

line 1551:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb[J

line 1552: endif[J

line 1553: [J

line 1554: " Rexx, Rebol or R[J

line 1555: au BufNewFile,BufRead *.r,*.R^I^I^Icall s:FTr()[J

line 1556: [J

line 1557: func! s:FTr()[J

line 1584: [J

line 1585: " Remind[J

line 1586: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')[J

line 1587: au BufNewFile,BufRead *.remind,*.rem^I^Isetf remind[J

line 1588: [J

line 1589: " Resolv.conf[J

line 1590: au BufNewFile,BufRead resolv.conf^I^Isetf resolv[J

line 1591: [J

line 1592: " Relax NG Compact[J

line 1593: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc[J

line 1594: [J

line 1595: " RPL/2[J

line 1596: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl[J

line 1597: [J

line 1598: " Robots.txt[J

line 1599: au BufNewFile,BufRead robots.txt^I^Isetf robots[J

line 1600: [J

line 1601: " Rpcgen[J

line 1602: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen[J

line 1603: [J

line 1604: " reStructuredText Documentation Format[J

line 1605: au BufNewFile,BufRead *.rst^I^I^Isetf rst[J

line 1606: [J

line 1607: " RTF[J

line 1608: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf[J

line 1609: [J

line 1610: " Interactive Ruby shell[J

line 1611: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby[J

line 1612: [J

line 1613: " Ruby[J

line 1614: au BufNewFile,BufRead *.rb,*.rbw,*.gem,*.gemspec^Isetf ruby[J

line 1615: [J

line 1616: " Ruby on Rails[J

line 1617: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby[J

line 1618: [J

line 1619: " Rantfile and Rakefile is like Ruby[J

line 1620: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby[J

line 1621: [J

line 1622: " S-lang (or shader language, or SmallLisp)[J

line 1623: au BufNewFile,BufRead *.sl^I^I^Isetf slang[J

line 1624: [J

line 1625: " Samba config[J

line 1626: au BufNewFile,BufRead smb.conf^I^I^Isetf samba[J

line 1627: [J

line 1628: " SAS script[J

line 1629: au BufNewFile,BufRead *.sas^I^I^Isetf sas[J

line 1630: [J

line 1631: " Sass[J

line 1632: au BufNewFile,BufRead *.sass^I^I^Isetf sass[J

line 1633: [J

line 1634: " Sather[J

line 1635: au BufNewFile,BufRead *.sa^I^I^Isetf sather[J

line 1636: [J

line 1637: " Scilab[J

line 1638: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab[J

line 1639: [J

line 1640: " SCSS[J

line 1641: au BufNewFile,BufRead *.scss ^I^I^Isetf scss[J

line 1642: [J

line 1643: " SD: Streaming Descriptors[J

line 1644: au BufNewFile,BufRead *.sd^I^I^Isetf sd[J

line 1645: [J

line 1646: " SDL[J

line 1647: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl[J

line 1648: [J

line 1649: " sed[J

line 1650: au BufNewFile,BufRead *.sed^I^I^Isetf sed[J

line 1651: [J

line 1652: " Sieve (RFC 3028)[J

line 1653: au BufNewFile,BufRead *.siv^I^I^Isetf sieve[J

line 1654: [J

line 1655: " Sendmail[J

line 1656: au BufNewFile,BufRead sendmail.cf^I^Isetf sm[J

line 1657: [J

line 1658: " Sendmail .mc files are actually m4.  Could also be MS Message text file.[J

line 1659: au BufNewFile,BufRead *.mc^I^I^Icall s:McSetf()[J

line 1660: [J

line 1661: func! s:McSetf()[J

line 1676: [J

line 1677: " Services[J

line 1678: au BufNewFile,BufRead /etc/services^I^Isetf services[J

line 1679: [J

line 1680: " Service Location config[J

line 1681: au BufNewFile,BufRead /etc/slp.conf^I^Isetf slpconf[J

line 1682: [J

line 1683: " Service Location registration[J

line 1684: au BufNewFile,BufRead /etc/slp.reg^I^Isetf slpreg[J

line 1685: [J

line 1686: " Service Location SPI[J

line 1687: au BufNewFile,BufRead /etc/slp.spi^I^Isetf slpspi[J

line 1688: [J

line 1689: " Setserial config[J

line 1690: au BufNewFile,BufRead /etc/serial.conf^I^Isetf setserial[J

line 1691: [J

line 1692: " SGML[J

line 1701: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type="sgml" |   setf docbk | else |   setf sgml | endif[J

line 1702: [J

line 1703: " SGMLDECL[J

line 1707: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif[J

line 1708: [J

line 1709: " SGML catalog file[J

line 1710: au BufNewFile,BufRead catalog^I^I^Isetf catalog[J

line 1711: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')[J

line 1712: [J

line 1713: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.[J

line 1714: " Gentoo ebuilds are actually bash scripts[J

line 1715: au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,*.bash,*.ebuild call SetFileTypeSH("bash")[J

line 1716: au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")[J

line 1717: au BufNewFile,BufRead /etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))[J

line 1718: [J

line 1719: " Also called from scripts.vim.[J

line 1720: func! SetFileTypeSH(name)[J

line 1759: [J

line 1760: " For shell-like file types, check for an "exec" command hidden in a comment,[J

line 1761: " as used for Tcl.[J

line 1762: " Also called from scripts.vim, thus can't be local to this script.[J

line 1763: func! SetFileTypeShell(name)[J

line 1782: [J

line 1783: " tcsh scripts[J

line 1784: au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login^Icall SetFileTypeShell("tcsh")[J

line 1785: [J

line 1786: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)[J

line 1787: au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()[J

line 1788: [J

line 1789: func! s:CSH()[J

line 1798: [J

line 1799: " Z-Shell script[J

line 1800: au BufNewFile,BufRead .zprofile,/etc/zprofile,.zfbfmarks  setf zsh[J

line 1801: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')[J

line 1802: au BufNewFile,BufRead *.zsh ^I^I^Isetf zsh[J

line 1803: [J

line 1804: " Scheme[J

line 1805: au BufNewFile,BufRead *.scm,*.ss^I^Isetf scheme[J

line 1806: [J

line 1807: " Screen RC[J

line 1808: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen[J

line 1809: [J

line 1810: " Simula[J

line 1811: au BufNewFile,BufRead *.sim^I^I^Isetf simula[J

line 1812: [J

line 1813: " SINDA[J

line 1814: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda[J

line 1815: [J

line 1816: " SiSU[J

line 1817: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu[J

line 1818: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu[J

line 1819: [J

line 1820: " SKILL[J

line 1821: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill[J

line 1822: [J

line 1823: " SLRN[J

line 1824: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc[J

line 1825: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc[J

line 1826: [J

line 1827: " Smalltalk (and TeX)[J

line 1828: au BufNewFile,BufRead *.st^I^I^Isetf st[J

line 1834: au BufNewFile,BufRead *.cls if getline(1) =~ '^%' |  setf tex | else |  setf st | endif[J

line 1835: [J

line 1836: " Smarty templates[J

line 1837: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty[J

line 1838: [J

line 1839: " SMIL or XML[J

line 1845: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif[J

line 1846: [J

line 1847: " SMIL or SNMP MIB file[J

line 1853: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif[J

line 1854: [J

line 1855: " SMITH[J

line 1856: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith[J

line 1857: [J

line 1858: " Snobol4 and spitbol[J

line 1859: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4[J

line 1860: [J

line 1861: " SNMP MIB files[J

line 1862: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib[J

line 1863: [J

line 1864: " Snort Configuration[J

line 1865: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog[J

line 1866: au BufNewFile,BufRead *.rules^I^I^Icall s:FTRules()[J

line 1867: [J

line 1868: let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'[J

line 1869: func! s:FTRules()[J

line 1897: [J

line 1898: [J

line 1899: " Spec (Linux RPM)[J

line 1900: au BufNewFile,BufRead *.spec^I^I^Isetf spec[J

line 1901: [J

line 1902: " Speedup (AspenTech plant simulator)[J

line 1903: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup[J

line 1904: [J

line 1905: " Slice[J

line 1906: au BufNewFile,BufRead *.ice^I^I^Isetf slice[J

line 1907: [J

line 1908: " Spice[J

line 1909: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice[J

line 1910: [J

line 1911: " Spyce[J

line 1912: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce[J

line 1913: [J

line 1914: " Squid[J

line 1915: au BufNewFile,BufRead squid.conf^I^Isetf squid[J

line 1916: [J

line 1917: " SQL for Oracle Designer[J

line 1918: au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks^Isetf sql[J

line 1919: [J

line 1920: " SQL[J

line 1921: au BufNewFile,BufRead *.sql^I^I^Icall s:SQL()[J

line 1922: [J

line 1923: func! s:SQL()[J

line 1930: [J

line 1931: " SQLJ[J

line 1932: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj[J

line 1933: [J

line 1934: " SQR[J

line 1935: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr[J

line 1936: [J

line 1937: " OpenSSH configuration[J

line 1938: au BufNewFile,BufRead ssh_config,*/.ssh/config^Isetf sshconfig[J

line 1939: [J

line 1940: " OpenSSH server configuration[J

line 1941: au BufNewFile,BufRead sshd_config^I^Isetf sshdconfig[J

line 1942: [J

line 1943: " Stata[J

line 1944: au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata[J

line 1945: [J

line 1946: " SMCL[J

line 1947: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl[J

line 1948: [J

line 1949: " Stored Procedures[J

line 1950: au BufNewFile,BufRead *.stp^I^I^Isetf stp[J

line 1951: [J

line 1952: " Standard ML[J

line 1953: au BufNewFile,BufRead *.sml^I^I^Isetf sml[J

line 1954: [J

line 1955: " Sratus VOS command macro[J

line 1956: au BufNewFile,BufRead *.cm^I^I^Isetf voscm[J

line 1957: [J

line 1958: " Sysctl[J

line 1959: au BufNewFile,BufRead /etc/sysctl.conf^I^Isetf sysctl[J

line 1960: [J

line 1961: " Synopsys Design Constraints[J

line 1962: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc[J

line 1963: [J

line 1964: " Sudoers[J

line 1965: au BufNewFile,BufRead /etc/sudoers,sudoers.tmp^Isetf sudoers[J

line 1966: [J

line 1967: " SVG (Scalable Vector Graphics)[J

line 1968: au BufNewFile,BufRead *.svg^I^I^Isetf svg[J

line 1969: [J

line 1970: " If the file has an extension of 't' and is in a directory 't' then it is[J

line 1971: " almost certainly a Perl test file.[J

line 1972: " If the first line starts with '#' and contains 'perl' it's probably a Perl[J

line 1973: " file.[J

line 1974: " (Slow test) If a file contains a 'use' statement then it is almost certainly[J

line 1975: " a Perl file.[J

line 1976: func! s:FTperl()[J

line 1991: [J

line 1992: " Tads (or Nroff or Perl test file)[J

line 1994: au BufNewFile,BufRead *.t if !s:FTnroff() && !s:FTperl() | setf tads | endif[J

line 1995: [J

line 1996: " Tags[J

line 1997: au BufNewFile,BufRead tags^I^I^Isetf tags[J

line 1998: [J

line 1999: " TAK[J

line 2000: au BufNewFile,BufRead *.tak^I^I^Isetf tak[J

line 2001: [J

line 2002: " Task[J

line 2003: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata[J

line 2004: au BufRead,BufNewFile *.task                    setf taskedit[J

line 2005: [J

line 2006: " Tcl (JACL too)[J

line 2007: au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl^Isetf tcl[J

line 2008: [J

line 2009: " TealInfo[J

line 2010: au BufNewFile,BufRead *.tli^I^I^Isetf tli[J

line 2011: [J

line 2012: " Telix Salt[J

line 2013: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt[J

line 2014: [J

line 2015: " Terminfo[J

line 2016: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo[J

line 2017: [J

line 2018: " TeX[J

line 2019: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex[J

line 2020: au BufNewFile,BufRead *.tex^I^I^Icall s:FTtex()[J

line 2021: [J

line 2022: " Choose context, plaintex, or tex (LaTeX) based on these rules:[J

line 2023: " 1. Check the first line of the file for "%&<format>".[J

line 2024: " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.[J

line 2025: " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.[J

line 2026: func! s:FTtex()[J

line 2073: [J

line 2074: " ConTeXt[J

line 2075: au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context[J

line 2076: [J

line 2077: " Texinfo[J

line 2078: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo[J

line 2079: [J

line 2080: " TeX configuration[J

line 2081: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf[J

line 2082: [J

line 2083: " Tidy config[J

line 2084: au BufNewFile,BufRead .tidyrc,tidyrc^I^Isetf tidy[J

line 2085: [J

line 2086: " TF mud client[J

line 2087: au BufNewFile,BufRead *.tf,.tfrc,tfrc^I^Isetf tf[J

line 2088: [J

line 2089: " TPP - Text Presentation Program[J

line 2090: au BufNewFile,BufReadPost *.tpp^I^I^Isetf tpp[J

line 2091: [J

line 2092: " Trustees[J

line 2093: au BufNewFile,BufRead trustees.conf^I^Isetf trustees[J

line 2094: [J

line 2095: " TSS - Geometry[J

line 2096: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm[J

line 2097: [J

line 2098: " TSS - Optics[J

line 2099: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop[J

line 2100: [J

line 2101: " TSS - Command Line (temporary)[J

line 2102: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl[J

line 2103: [J

line 2104: " Motif UIT/UIL files[J

line 2105: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil[J

line 2106: [J

line 2107: " Udev conf[J

line 2108: au BufNewFile,BufRead /etc/udev/udev.conf^Isetf udevconf[J

line 2109: [J

line 2110: " Udev permissions[J

line 2111: au BufNewFile,BufRead /etc/udev/permissions.d/*.permissions setf udevperm[J

line 2112: "[J

line 2113: " Udev symlinks config[J

line 2114: au BufNewFile,BufRead /etc/udev/cdsymlinks.conf^Isetf sh[J

line 2115: [J

line 2116: " UnrealScript[J

line 2117: au BufNewFile,BufRead *.uc^I^I^Isetf uc[J

line 2118: [J

line 2119: " Updatedb[J

line 2120: au BufNewFile,BufRead /etc/updatedb.conf^Isetf updatedb[J

line 2121: [J

line 2122: " Vera[J

line 2123: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera[J

line 2124: [J

line 2125: " Verilog HDL[J

line 2126: au BufNewFile,BufRead *.v^I^I^Isetf verilog[J

line 2127: [J

line 2128: " Verilog-AMS HDL[J

line 2129: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams[J

line 2130: [J

line 2131: " VHDL[J

line 2132: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl[J

line 2133: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')[J

line 2134: [J

line 2135: " Vim script[J

line 2136: au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc^Isetf vim[J

line 2137: [J

line 2138: " Viminfo file[J

line 2139: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo[J

line 2140: [J

line 2141: " Virata Config Script File or Drupal module[J

line 2147: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif[J

line 2148: [J

line 2149: " Visual Basic (also uses *.bas) or FORM[J

line 2150: au BufNewFile,BufRead *.frm^I^I^Icall s:FTVB("form")[J

line 2151: [J

line 2152: " SaxBasic is close to Visual Basic[J

line 2153: au BufNewFile,BufRead *.sba^I^I^Isetf vb[J

line 2154: [J

line 2155: " Vgrindefs file[J

line 2156: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs[J

line 2157: [J

line 2158: " VRML V1.0c[J

line 2159: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml[J

line 2160: [J

line 2161: " Webmacro[J

line 2162: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro[J

line 2163: [J

line 2164: " Wget config[J

line 2165: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget[J

line 2166: [J

line 2167: " Website MetaLanguage[J

line 2168: au BufNewFile,BufRead *.wml^I^I^Isetf wml[J

line 2169: [J

line 2170: " Winbatch[J

line 2171: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch[J

line 2172: [J

line 2173: " WSML[J

line 2174: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml[J

line 2175: [J

line 2176: " WvDial[J

line 2177: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial[J

line 2178: [J

line 2179: " CVS RC file[J

line 2180: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc[J

line 2181: [J

line 2182: " CVS commit file[J

line 2183: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs[J

line 2184: [J

line 2185: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment[J

line 2186: " lines in a WEB file).[J

line 2192: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif[J

line 2193: [J

line 2194: " Windows Scripting Host and Windows Script Component[J

line 2195: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh[J

line 2196: [J

line 2197: " XHTML[J

line 2198: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml[J

line 2199: [J

line 2200: " X Pixmap (dynamically sets colors, use BufEnter to make it work better)[J

line 2206: au BufEnter *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif[J

line 2207: au BufEnter *.xpm2^I^I^I^Isetf xpm2[J

line 2208: [J

line 2209: " XFree86 config[J

line 2214: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86c_xfree86_version = 3 | endif | setf xf86conf[J

line 2215: [J

line 2216: " Xorg config[J

line 2217: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86c_xfree86_version = 4 | setf xf86conf[J

line 2218: [J

line 2219: " Xinetd conf[J

line 2220: au BufNewFile,BufRead /etc/xinetd.conf^I^Isetf xinetd[J

line 2221: [J

line 2222: " XS Perl extension interface language[J

line 2223: au BufNewFile,BufRead *.xs^I^I^Isetf xs[J

line 2224: [J

line 2225: " X resources file[J

line 2226: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults[J

line 2227: [J

line 2228: " Xmath[J

line 2229: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath[J

line 2231: au BufNewFile,BufRead *.ms if !s:FTnroff() | setf xmath | endif[J

line 2232: [J

line 2233: " XML  specific variants: docbk and xbl[J

line 2234: au BufNewFile,BufRead *.xml^I^I^Icall s:FTxml()[J

line 2235: [J

line 2236: func! s:FTxml()[J

line 2253: [J

line 2254: " XMI (holding UML models) is also XML[J

line 2255: au BufNewFile,BufRead *.xmi^I^I^Isetf xml[J

line 2256: [J

line 2257: " CSPROJ files are Visual Studio.NET's XML-based project config files[J

line 2258: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml[J

line 2259: [J

line 2260: " Qt Linguist translation source and Qt User Interface Files are XML[J

line 2261: au BufNewFile,BufRead *.ts,*.ui^I^I^Isetf xml[J

line 2262: [J

line 2263: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)[J

line 2264: au BufNewFile,BufRead *.tpm^I^I^Isetf xml[J

line 2265: [J

line 2266: " Xdg menus[J

line 2267: au BufNewFile,BufRead /etc/xdg/menus/*.menu^Isetf xml[J

line 2268: [J

line 2269: " ATI graphics driver configuration[J

line 2270: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml[J

line 2271: [J

line 2272: " XLIFF (XML Localisation Interchange File Format) is also XML[J

line 2273: au BufNewFile,BufRead *.xlf^I^I^Isetf xml[J

line 2274: au BufNewFile,BufRead *.xliff^I^I^Isetf xml[J

line 2275: [J

line 2276: " X11 xmodmap (also see below)[J

line 2277: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap[J

line 2278: [J

line 2279: " Xquery[J

line 2280: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery[J

line 2281: [J

line 2282: " XSD[J

line 2283: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd[J

line 2284: [J

line 2285: " Xslt[J

line 2286: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt[J

line 2287: [J

line 2288: " Yacc[J

line 2289: au BufNewFile,BufRead *.yy^I^I^Isetf yacc[J

line 2290: [J

line 2291: " Yacc or racc[J

line 2292: au BufNewFile,BufRead *.y^I^I^Icall s:FTy()[J

line 2293: [J

line 2294: func! s:FTy()[J

line 2310: [J

line 2311: [J

line 2312: " Yaml[J

line 2313: au BufNewFile,BufRead *.yaml,*.yml^I^Isetf yaml[J

line 2314: [J

line 2315: " Zope[J

line 2316: "   dtml (zope dynamic template markup language), pt (zope page template),[J

line 2317: "   cpt (zope form controller page template)[J

line 2318: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall s:FThtml()[J

line 2319: "   zsql (zope sql method)[J

line 2320: au BufNewFile,BufRead *.zsql^I^I^Icall s:SQL()[J

line 2321: [J

line 2322: " Z80 assembler asz80[J

line 2323: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a[J

line 2324: [J

line 2325: augroup END[J

line 2326: [J

line 2327: [J

line 2328: " Source the user-specified filetype file, for backwards compatibility with[J

line 2329: " Vim 5.x.[J

line 2330: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))[J

line 2331:   execute "source " . myfiletypefile[J

line 2332: endif[J

line 2333: [J

line 2334: [J

line 2335: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used[J

line 2336: " when there are no matching file name extensions.[J

line 2337: " Don't do this for compressed files.[J

line 2338: augroup filetypedetect[J

line 2341: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif[J

line 2342: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif[J

line 2343: [J

line 2344: [J

line 2345: " Extra checks for when no filetype has been detected now.  Mostly used for[J

line 2346: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim[J

line 2347: " script file.[J

line 2348: " Most of these should call s:StarSetf() to avoid names ending in .gz and the[J

line 2349: " like are used.[J

line 2350: [J

line 2351: " More Apache files.[J

line 2352: au BufNewFile,BufRead /etc/apache2/conf.*/*,/etc/apache2/sites-*/*,/etc/apache2/mods-*/*^I^Icall s:StarSetf('apache')[J

line 2353: [J

line 2354: " Asterisk config file[J

line 2355: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')[J

line 2356: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')[J

line 2357: [J

line 2358: " Bazaar version control[J

line 2359: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr[J

line 2360: [J

line 2361: " BIND zone[J

line 2362: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')[J

line 2363: [J

line 2364: " Changelog[J

line 2370: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif[J

line 2371: [J

line 2372: " Crontab[J

line 2373: au BufNewFile,BufRead crontab,crontab.*,/etc/cron.d/*^I^Icall s:StarSetf('crontab')[J

line 2374: [J

line 2375: " Debian Sources.list[J

line 2376: au BufNewFile,BufRead /etc/apt/sources.list.d/*^Icall s:StarSetf('debsources')[J

line 2377: [J

line 2378: " Dracula[J

line 2379: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')[J

line 2380: [J

line 2381: " Fvwm[J

line 2382: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')[J

line 2384: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')[J

line 2390: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif[J

line 2391: [J

line 2392: " Gedcom[J

line 2393: au BufNewFile,BufRead /tmp/lltmp*^I^Icall s:StarSetf('gedcom')[J

line 2394: [J

line 2395: " GTK RC[J

line 2396: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')[J

line 2397: [J

line 2398: " Jam[J

line 2399: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')[J

line 2400: [J

line 2401: " Jargon[J

line 2405: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif[J

line 2406: [J

line 2407: " Kconfig[J

line 2408: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')[J

line 2409: [J

line 2410: " Logcheck[J

line 2411: au BufNewFile,BufRead /etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')[J

line 2412: [J

line 2413: " Makefile[J

line 2414: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')[J

line 2415: [J

line 2416: " Ruby Makefile[J

line 2417: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')[J

line 2418: [J

line 2419: " Mail (also matches muttrc.vim, so this is below the other checks)[J

line 2420: au BufNewFile,BufRead mutt[[:alnum:]._-]\{6\}^Isetf mail[J

line 2421: [J

line 2422: " Modconf[J

line 2423: au BufNewFile,BufRead /etc/modprobe.*^I^Icall s:StarSetf('modconf')[J

line 2424: [J

line 2425: " Mutt setup file[J

line 2426: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')[J

line 2427: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')[J

line 2428: [J

line 2429: " Nroff macros[J

line 2430: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')[J

line 2431: [J

line 2432: " Pam conf[J

line 2433: au BufNewFile,BufRead /etc/pam.d/*^I^Icall s:StarSetf('pamconf')[J

line 2434: [J

line 2435: " Printcap and Termcap[J

line 2439: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif[J

line 2443: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif[J

line 2444: [J

line 2445: " Vim script[J

line 2446: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')[J

line 2447: [J

line 2448: " Subversion commit file[J

line 2449: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn[J

line 2450: [J

line 2451: " X resources file[J

line 2452: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')[J

line 2453: [J

line 2454: " XFree86 config[J

line 2456: au BufNewFile,BufRead XF86Config-4* let b:xf86c_xfree86_version = 4 | call s:StarSetf('xf86conf')[J

line 2461: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86c_xfree86_version = 3|endif|call s:StarSetf('xf86conf')[J

line 2462: [J

line 2463: " X11 xmodmap[J

line 2464: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')[J

line 2465: [J

line 2466: " Xinetd conf[J

line 2467: au BufNewFile,BufRead /etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')[J

line 2468: [J

line 2469: " Z-Shell script[J

line 2470: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')[J

line 2471: [J

line 2472: [J

line 2473: [J

line 2474: " Use the filetype detect plugins.  They may overrule any of the previously[J

line 2475: " detected filetypes.[J

line 2476: runtime! ftdetect/*.vim[J

Searching for "ftdetect/*.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after"[J
Searching for "/home/vimtest/.vim/ftdetect/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/ftdetect/*.vim"[J
Searching for "/usr/local/share/vim/vim73/ftdetect/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/ftdetect/*.vim"[J
Searching for "/home/vimtest/.vim/after/ftdetect/*.vim"[J
not found in 'runtimepath': "ftdetect/*.vim"[J
line 2477: [J

line 2478: [J

line 2479: " Generic configuration file (check this last, it's just guessing!)[J

line 2485: au BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'^I|| getline(4) =~ '^#' || getline(5) =~ '^#') |   setf conf | endif[J

line 2486: [J

line 2487: augroup END[J

line 2488: [J

line 2489: [J

line 2490: " If the GUI is already running, may still need to install the Syntax menu.[J

line 2491: " Don't do it when the 'M' flag is included in 'guioptions'.[J

line 2493: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"[J

line 2494:   source <sfile>:p:h/menu.vim[J

line 2495: endif[J

line 2496: [J

line 2497: " Function called for testing all functions defined here.  These are[J

line 2498: " script-local, thus need to be executed here.[J

line 2499: " Returns a string with error messages (hopefully empty).[J

line 2500: func! TestFiletypeFuncs(testlist)[J

line 2511: [J

line 2512: " Restore 'cpoptions'[J

line 2513: let &cpo = s:cpo_save[J

line 2514: unlet s:cpo_save[J

finished sourcing /usr/local/share/vim/vim73/filetype.vim[J
continuing in /home/vimtest/.vim/bundles.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/home/vimtest/.vim/after/filetype.vim"[J
Searching for "ftplugin.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after"[J
Searching for "/home/vimtest/.vim/ftplugin.vim"[J
Searching for "/usr/local/share/vim/vimfiles/ftplugin.vim"[J
Searching for "/usr/local/share/vim/vim73/ftplugin.vim"[J
chdir(/usr/local/share/vim/vim73)[J
fchdir() to previous dir[J
line 3: sourcing "/usr/local/share/vim/vim73/ftplugin.vim"[J
line 1: " Vim support file to switch on loading plugins for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last change:^I2006 Apr 30[J

line 5: [J

line 6: if exists("did_load_ftplugin")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_load_ftplugin = 1[J

line 10: [J

line 11: augroup filetypeplugin[J

line 12:   au FileType * call s:LoadFTPlugin()[J

line 13: [J

line 14:   func! s:LoadFTPlugin()[J

line 35: augroup END[J

finished sourcing /usr/local/share/vim/vim73/ftplugin.vim[J
continuing in /home/vimtest/.vim/bundles.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/ftplugin.vim"[J
Searching for "/home/vimtest/.vim/after/ftplugin.vim"[J
Searching for "indent.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after"[J
Searching for "/home/vimtest/.vim/indent.vim"[J
Searching for "/usr/local/share/vim/vimfiles/indent.vim"[J
Searching for "/usr/local/share/vim/vim73/indent.vim"[J
chdir(/usr/local/share/vim/vim73)[J
fchdir() to previous dir[J
line 3: sourcing "/usr/local/share/vim/vim73/indent.vim"[J
line 1: " Vim support file to switch on loading indent files for file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2008 Feb 22[J

line 5: [J

line 6: if exists("did_indent_on")[J

line 7:   finish[J

line 8: endif[J

line 9: let did_indent_on = 1[J

line 10: [J

line 11: augroup filetypeindent[J

line 12:   au FileType * call s:LoadIndent()[J

line 13:   func! s:LoadIndent()[J

line 31: augroup END[J

finished sourcing /usr/local/share/vim/vim73/indent.vim[J
continuing in /home/vimtest/.vim/bundles.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/indent.vim"[J
Searching for "/home/vimtest/.vim/after/indent.vim"[J
line 4: [J

line 5: set rtp+=~/.vim/bundle/vundle/[J

line 6: call vundle#rc()[J

Searching for "autoload/vundle.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/"[J
Searching for "/home/vimtest/.vim/autoload/vundle.vim"[J
Searching for "/usr/local/share/vim/vimfiles/autoload/vundle.vim"[J
Searching for "/usr/local/share/vim/vim73/autoload/vundle.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/autoload/vundle.vim"[J
Searching for "/home/vimtest/.vim/after/autoload/vundle.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/autoload/vundle.vim"[J
chdir(/home/vimtest/.vim/bundle/vundle/autoload)[J
fchdir() to previous dir[J
line 6: sourcing "/home/vimtest/.vim/bundle/vundle/autoload/vundle.vim"[J
line 1: " Vundle        is a shortcut for Vim Bundle and Is a simple plugin manager for Vim[J

line 2: " Author:       gmarik[J

line 3: " HomePage:     http://github.com/gmarik/vundle[J

line 4: " Readme:       http://github.com/gmarik/vundle/blob/master/README.md[J

line 5: " Version:      0.9[J

line 6: [J

line 8: com! -nargs=+         Bundle call vundle#config#bundle(<args>)[J

line 9: [J

line 11: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleInstall call vundle#installer#new('!' == '<bang>', <q-args>)[J

line 12: [J

line 14: com! -nargs=? -bang -complete=custom,vundle#scripts#complete BundleSearch call vundle#scripts#all('!'=='<bang>', <q-args>)[J

line 15: [J

line 17: com! -nargs=? -bang -complete=custom,vundle#scripts#complete Bundles call vundle#scripts#all('!'=='<bang>', <q-args>)[J

line 18: [J

line 20: com! -nargs=0 -bang BundleList call vundle#installer#list('!'=='<bang>')[J

line 21: [J

line 23: com! -nargs=? -bang   BundleClean call vundle#installer#clean('!' == '<bang>')[J

line 24: [J

line 26: com! -nargs=0         BundleDocs  call vundle#installer#helptags(g:bundles)[J

line 27: [J

line 28: [J

line 29: if (has('signs'))[J

line 30: sign define Vu_error    text=!  texthl=Error[J

line 31: sign define Vu_active   text=>  texthl=Comment[J

line 32: sign define Vu_todate   text=.  texthl=Comment[J

line 33: sign define Vu_updated  text=+  texthl=Comment[J

line 34: sign define Vu_deleted  text=-  texthl=Comment[J

line 35: endif[J

line 36: [J

line 37: [J

line 38: func! vundle#rc(...) abort[J

finished sourcing /home/vimtest/.vim/bundle/vundle/autoload/vundle.vim[J
continuing in /home/vimtest/.vim/bundles.vim[J
calling function vundle#rc[J()

line 1:   let g:bundle_dir = len(a:000) > 0 ? expand(a:1, 1) : expand('$HOME/.vim/bundle', 1)[J

line 2:   let g:vundle_log = [][J

line 3:   call vundle#config#init()[J

Searching for "autoload/vundle/config.vim" in "/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/"[J
Searching for "/home/vimtest/.vim/autoload/vundle/config.vim"[J
Searching for "/usr/local/share/vim/vimfiles/autoload/vundle/config.vim"[J
Searching for "/usr/local/share/vim/vim73/autoload/vundle/config.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/autoload/vundle/config.vim"[J
Searching for "/home/vimtest/.vim/after/autoload/vundle/config.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/autoload/vundle/config.vim"[J
chdir(/home/vimtest/.vim/bundle/vundle/autoload/vundle)[J
fchdir() to previous dir[J
line 3: sourcing "/home/vimtest/.vim/bundle/vundle/autoload/vundle/config.vim"[J
line 1: func! vundle#config#bundle(arg, ...)[J

line 7: [J

line 8: func! vundle#config#init()[J

line 13: [J

line 14: func! vundle#config#require(bundles) abort[J

line 24: [J

line 25: func! vundle#config#init_bundle(name, opts)[J

line 29: [J

line 30: func! s:parse_options(opts)[J

line 40: [J

line 41: func! s:parse_name(arg)[J

line 62: [J

line 63: func! s:rtp_rm_a()[J

line 66: [J

line 67: func! s:rtp_add_a()[J

line 70: [J

line 71: func! s:rtp_rm(dir) abort[J

line 75: [J

line 76: func! s:rtp_add(dir) abort[J

line 80: [J

line 81: func! s:expand_path(path) abort[J

line 84: [J

line 85: let s:bundle = {}[J

line 86: [J

line 87: func! s:bundle.path()[J

line 90: [J

line 91: func! s:bundle.rtpath()[J

finished sourcing /home/vimtest/.vim/bundle/vundle/autoload/vundle/config.vim[J
continuing in function vundle#rc[J
calling function vundle#rc..vundle#config#init[J()

line 1:   if !exists('g:bundles') | let g:bundles = [] | endif[J

line 1:  let g:bundles = [] | endif[J

line 1:  endif[J

line 2:   call s:rtp_rm_a()[J

calling function vundle#rc..vundle#config#init..<SNR>8_rtp_rm_a[J()

line 1:   call filter(copy(g:bundles), 's:rtp_rm(v:val.rtpath())')[J

function vundle#rc..vundle#config#init..<SNR>8_rtp_rm_a returning #0[J

continuing in function vundle#rc..vundle#config#init[J

line 3:   let g:bundles = [][J

function vundle#rc..vundle#config#init returning #0[J

continuing in function vundle#rc[J

function vundle#rc returning #0[J

continuing in /home/vimtest/.vim/bundles.vim[J

line 7: [J

line 8: Bundle 'gmarik/vundle'[J

line 8: call vundle#config#bundle('gmarik/vundle')[J

calling function vundle#config#bundle[J('gmarik/vundle')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle..vundle#config#init_bundle[J('gmarik/vundle', [])

line 1:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')))[J

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_options returning {}[J

continuing in function vundle#config#bundle..vundle#config#init_bundle[J

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_name[J('gmarik/vundle')

line 1:   let arg = a:arg[J

line 2: [J

line 3:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 5:     let uri = 'https://github.com/'.split(arg, ':')[-1][J

line 6:     if uri !~? '\.git$'[J

line 7:       let uri .= '.git'[J

line 8:     endif[J

line 9:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 10:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'    || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 13:     let uri = arg[J

line 14:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 15:   else[J

line 16:     let name = arg[J

line 17:     let uri  = 'https://github.com/vim-scripts/'.name.'.git'[J

line 18:   endif[J

line 19:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_name returning {'uri': 'https://github.com/gmarik/vu... 'vundle', 'name_spec': 'gmarik/vundle'}[J

continuing in function vundle#config#bundle..vundle#config#init_bundle[J

line 2:   return extend(opts, copy(s:bundle))[J

function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/gmarik/vu... 'gmarik/vundle', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   call s:rtp_rm_a()[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a[J()

line 1:   call filter(copy(g:bundles), 's:rtp_rm(v:val.rtpath())')[J

function vundle#config#bundle..<SNR>8_rtp_rm_a returning #0[J

continuing in function vundle#config#bundle[J

line 3:   call add(g:bundles, bundle)[J

line 4:   call s:rtp_add_a()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a[J()

line 1:   call filter(reverse(copy(g:bundles)), 's:rtp_add(v:val.rtpath())')[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add[J('/home/vimtest/.vim/bundle/vundle')

line 1:   exec 'set rtp^='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp^=/home/vimtest/.vim/bundle/vundle[J

line 2:   exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp+=/home/vimtest/.vim/bundle/vundle/after[J

function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

function vundle#config#bundle..<SNR>8_rtp_add_a returning #0[J

continuing in function vundle#config#bundle[J

function vundle#config#bundle returning #0[J

continuing in /home/vimtest/.vim/bundles.vim[J

line 9: Bundle 'scrooloose/nerdtree'[J

line 9: call vundle#config#bundle('scrooloose/nerdtree')[J

calling function vundle#config#bundle[J('scrooloose/nerdtree')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle..vundle#config#init_bundle[J('scrooloose/nerdtree', [])

line 1:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')))[J

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_options returning {}[J

continuing in function vundle#config#bundle..vundle#config#init_bundle[J

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_name[J('scrooloose/nerdtree')

line 1:   let arg = a:arg[J

line 2: [J

line 3:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 5:     let uri = 'https://github.com/'.split(arg, ':')[-1][J

line 6:     if uri !~? '\.git$'[J

line 7:       let uri .= '.git'[J

line 8:     endif[J

line 9:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 10:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'    || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 13:     let uri = arg[J

line 14:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 15:   else[J

line 16:     let name = arg[J

line 17:     let uri  = 'https://github.com/vim-scripts/'.name.'.git'[J

line 18:   endif[J

line 19:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_name returning {'uri': 'https://github.com/scrooloos...ee', 'name_spec': 'scrooloose/nerdtree'}[J

continuing in function vundle#config#bundle..vundle#config#init_bundle[J

line 2:   return extend(opts, copy(s:bundle))[J

function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/scrooloos...oloose/nerdtree', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   call s:rtp_rm_a()[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a[J()

line 1:   call filter(copy(g:bundles), 's:rtp_rm(v:val.rtpath())')[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a..2[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..<SNR>8_rtp_rm[J('/home/vimtest/.vim/bundle/vundle')

line 1:   exec 'set rtp-='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp-=/home/vimtest/.vim/bundle/vundle[J

line 2:   exec 'set rtp-='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp-=/home/vimtest/.vim/bundle/vundle/after[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..<SNR>8_rtp_rm returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a[J

function vundle#config#bundle..<SNR>8_rtp_rm_a returning #0[J

continuing in function vundle#config#bundle[J

line 3:   call add(g:bundles, bundle)[J

line 4:   call s:rtp_add_a()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a[J()

line 1:   call filter(reverse(copy(g:bundles)), 's:rtp_add(v:val.rtpath())')[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/nerdtree')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1 returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2 returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add[J('/home/vimtest/.vim/bundle/nerdtree')

line 1:   exec 'set rtp^='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp^=/home/vimtest/.vim/bundle/nerdtree[J

line 2:   exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp+=/home/vimtest/.vim/bundle/nerdtree/after[J

function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add[J('/home/vimtest/.vim/bundle/vundle')

line 1:   exec 'set rtp^='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp^=/home/vimtest/.vim/bundle/vundle[J

line 2:   exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp+=/home/vimtest/.vim/bundle/vundle/after[J

function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

function vundle#config#bundle..<SNR>8_rtp_add_a returning #0[J

continuing in function vundle#config#bundle[J

function vundle#config#bundle returning #0[J

continuing in /home/vimtest/.vim/bundles.vim[J

line 10: Bundle 'tpope/vim-rails'[J

line 10: call vundle#config#bundle('tpope/vim-rails')[J

calling function vundle#config#bundle[J('tpope/vim-rails')

line 1:   let bundle = vundle#config#init_bundle(a:arg, a:000)[J

calling function vundle#config#bundle..vundle#config#init_bundle[J('tpope/vim-rails', [])

line 1:   let opts = extend(s:parse_options(a:opts), s:parse_name(substitute(a:name,"['".'"]\+','','g')))[J

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_options[J([])

line 1:   " TODO: improve this[J

line 2:   if len(a:opts) != 1 | return {} | endif[J

line 2:  return {} | endif[J

function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_options returning {}[J

continuing in function vundle#config#bundle..vundle#config#init_bundle[J

calling function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_name[J('tpope/vim-rails')

line 1:   let arg = a:arg[J

line 2: [J

line 3:   if    arg =~? '^\s*\(gh\|github\):\S\+'  || arg =~? '^[a-z0-9][a-z0-9-]*/[^/]\+$'[J

line 5:     let uri = 'https://github.com/'.split(arg, ':')[-1][J

line 6:     if uri !~? '\.git$'[J

line 7:       let uri .= '.git'[J

line 8:     endif[J

line 9:     let name = substitute(split(uri,'\/')[-1], '\.git\s*$','','i')[J

line 10:   elseif arg =~? '^\s*\(git@\|git://\)\S\+'    || arg =~? '\(file\|https\?\)://'   || arg =~? '\.git\s*$'[J

line 13:     let uri = arg[J

line 14:     let name = split( substitute(uri,'/\?\.git\s*$','','i') ,'\/')[-1][J

line 15:   else[J

line 16:     let name = arg[J

line 17:     let uri  = 'https://github.com/vim-scripts/'.name.'.git'[J

line 18:   endif[J

line 19:   return {'name': name, 'uri': uri, 'name_spec': arg }[J

function vundle#config#bundle..vundle#config#init_bundle..<SNR>8_parse_name returning {'uri': 'https://github.com/tpope/vim...-rails', 'name_spec': 'tpope/vim-rails'}[J

continuing in function vundle#config#bundle..vundle#config#init_bundle[J

line 2:   return extend(opts, copy(s:bundle))[J

function vundle#config#bundle..vundle#config#init_bundle returning {'uri': 'https://github.com/tpope/vim...tpope/vim-rails', 'path': function('1')}[J

continuing in function vundle#config#bundle[J

line 2:   call s:rtp_rm_a()[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a[J()

line 1:   call filter(copy(g:bundles), 's:rtp_rm(v:val.rtpath())')[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a..2[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..<SNR>8_rtp_rm[J('/home/vimtest/.vim/bundle/vundle')

line 1:   exec 'set rtp-='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp-=/home/vimtest/.vim/bundle/vundle[J

line 2:   exec 'set rtp-='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp-=/home/vimtest/.vim/bundle/vundle/after[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..<SNR>8_rtp_rm returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/nerdtree')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2..1 returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a..2[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..2 returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a[J

calling function vundle#config#bundle..<SNR>8_rtp_rm_a..<SNR>8_rtp_rm[J('/home/vimtest/.vim/bundle/nerdtree')

line 1:   exec 'set rtp-='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp-=/home/vimtest/.vim/bundle/nerdtree[J

line 2:   exec 'set rtp-='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp-=/home/vimtest/.vim/bundle/nerdtree/after[J

function vundle#config#bundle..<SNR>8_rtp_rm_a..<SNR>8_rtp_rm returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_rm_a[J

function vundle#config#bundle..<SNR>8_rtp_rm_a returning #0[J

continuing in function vundle#config#bundle[J

line 3:   call add(g:bundles, bundle)[J

line 4:   call s:rtp_add_a()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a[J()

line 1:   call filter(reverse(copy(g:bundles)), 's:rtp_add(v:val.rtpath())')[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/vim-rails')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/vim-rails'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1 returning '/home/vimtest/.vim/bundle/vim-rails'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2 returning '/home/vimtest/.vim/bundle/vim-rails'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add[J('/home/vimtest/.vim/bundle/vim-rails')

line 1:   exec 'set rtp^='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp^=/home/vimtest/.vim/bundle/vim-rails[J

line 2:   exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp+=/home/vimtest/.vim/bundle/vim-rails/after[J

function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/nerdtree')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1 returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2 returning '/home/vimtest/.vim/bundle/nerdtree'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add[J('/home/vimtest/.vim/bundle/nerdtree')

line 1:   exec 'set rtp^='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp^=/home/vimtest/.vim/bundle/nerdtree[J

line 2:   exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp+=/home/vimtest/.vim/bundle/nerdtree/after[J

function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2[J()

line 1:   return has_key(self, 'rtp') ? s:expand_path(self.path().'/'.self.rtp) : self.path()[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J()

line 1:   return s:expand_path(g:bundle_dir.'/'.self.name)[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path[J('/home/vimtest/.vim/bundle/vundle')

line 1:   return simplify(expand(a:path, 1))[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1..<SNR>8_expand_path returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2..1[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2..1 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a..2[J

function vundle#config#bundle..<SNR>8_rtp_add_a..2 returning '/home/vimtest/.vim/bundle/vundle'[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

calling function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add[J('/home/vimtest/.vim/bundle/vundle')

line 1:   exec 'set rtp^='.fnameescape(expand(a:dir, 1))[J

line 1: set rtp^=/home/vimtest/.vim/bundle/vundle[J

line 2:   exec 'set rtp+='.fnameescape(expand(a:dir.'/after', 1))[J

line 2: set rtp+=/home/vimtest/.vim/bundle/vundle/after[J

function vundle#config#bundle..<SNR>8_rtp_add_a..<SNR>8_rtp_add returning #0[J

continuing in function vundle#config#bundle..<SNR>8_rtp_add_a[J

function vundle#config#bundle..<SNR>8_rtp_add_a returning #0[J

continuing in function vundle#config#bundle[J

function vundle#config#bundle returning #0[J

continuing in /home/vimtest/.vim/bundles.vim[J

line 11: [J

finished sourcing /home/vimtest/.vim/bundles.vim[J
continuing in /home/vimtest/.vimrc[J
line 2: [J

line 3: filetype on  " Automatically detect file types.[J

Searching for "filetype.vim" in "/home/vimtest/.vim/bundle/vundle,/home/vimtest/.vim/bundle/nerdtree,/home/vimtest/.vim/bundle/vim-rails,/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/,/home/vimtest/.vim/bundle/vim-rails/after,/home/vimtest/.vim/bundle/nerdtree/after,/home/vimtest/.vim/bundle/vundle/after"[J
Searching for "/home/vimtest/.vim/bundle/vundle/filetype.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/filetype.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/filetype.vim"[J
Searching for "/home/vimtest/.vim/filetype.vim"[J
Searching for "/usr/local/share/vim/vimfiles/filetype.vim"[J
Searching for "/usr/local/share/vim/vim73/filetype.vim"[J
chdir(/usr/local/share/vim/vim73)[J
fchdir() to previous dir[J
line 3: sourcing "/usr/local/share/vim/vim73/filetype.vim"[J
line 1: " Vim support file to detect file types[J

line 2: "[J

line 3: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 4: " Last Change:^I2010 Jul 30[J

line 5: [J

line 6: " Listen very carefully, I will say this only once[J

line 7: if exists("did_load_filetypes")[J

line 8:   finish[J

finished sourcing /usr/local/share/vim/vim73/filetype.vim[J
continuing in /home/vimtest/.vimrc[J
Searching for "/usr/local/share/vim/vimfiles/after/filetype.vim"[J
Searching for "/home/vimtest/.vim/after/filetype.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/filetype.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/after/filetype.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/after/filetype.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/after/filetype.vim"[J
line 4: set nocompatible  " We don't want vi compatibility.[J

line 5: [J

line 6: " Add recently accessed projects menu (project plugin)[J

line 7: set viminfo^=![J

line 8: [J

line 9: " Minibuffer Explorer Settings[J

line 10: let g:miniBufExplMapWindowNavVim = 1[J

line 11: let g:miniBufExplMapWindowNavArrows = 1[J

line 12: let g:miniBufExplMapCTabSwitchBufs = 1[J

line 13: let g:miniBufExplModSelTarget = 1[J

line 14: [J

line 15: " alt+n or alt+p to navigate between entries in QuickFix[J

line 16: map   :cp [J

No mapping found[J
line 17: map   :cn [J

No mapping found[J
line 18: [J

line 19: " Change which file opens after executing :Rails command[J

line 20: let g:rails_default_file='config/database.yml'[J

line 21: [J

line 22: syntax enable[J

line 22: so $VIMRUNTIME/syntax/syntax.vim[J

chdir(/usr/local/share/vim/vim73/syntax)[J
fchdir() to previous dir[J
line 22: sourcing "/usr/local/share/vim/vim73/syntax/syntax.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 04[J

line 4: [J

line 5: " This file is used for ":syntax on".[J

line 6: " It installs the autocommands and starts highlighting for all buffers.[J

line 7: [J

line 8: if !has("syntax")[J

line 9:   finish[J

line 10: endif[J

line 11: [J

line 12: " If Syntax highlighting appears to be on already, turn it off first, so that[J

line 13: " any leftovers are cleared.[J

line 14: if exists("syntax_on") || exists("syntax_manual")[J

line 15:   so <sfile>:p:h/nosyntax.vim[J

line 16: endif[J

line 17: [J

line 18: " Load the Syntax autocommands and set the default methods for highlighting.[J

line 19: runtime syntax/synload.vim[J

Searching for "syntax/synload.vim" in "/home/vimtest/.vim/bundle/vundle,/home/vimtest/.vim/bundle/nerdtree,/home/vimtest/.vim/bundle/vim-rails,/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/,/home/vimtest/.vim/bundle/vim-rails/after,/home/vimtest/.vim/bundle/nerdtree/after,/home/vimtest/.vim/bundle/vundle/after"[J
Searching for "/home/vimtest/.vim/bundle/vundle/syntax/synload.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/syntax/synload.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/syntax/synload.vim"[J
Searching for "/home/vimtest/.vim/syntax/synload.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/synload.vim"[J
Searching for "/usr/local/share/vim/vim73/syntax/synload.vim"[J
chdir(/usr/local/share/vim/vim73/syntax)[J
fchdir() to previous dir[J
line 19: sourcing "/usr/local/share/vim/vim73/syntax/synload.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2010 Aug 08[J

line 4: [J

line 5: " This file sets up for syntax highlighting.[J

line 6: " It is loaded from "syntax.vim" and "manual.vim".[J

line 7: " 1. Set the default highlight groups.[J

line 8: " 2. Install Syntax autocommands for all the available syntax files.[J

line 9: [J

line 10: if !has("syntax")[J

line 11:   finish[J

line 12: endif[J

line 13: [J

line 14: " let others know that syntax has been switched on[J

line 15: let syntax_on = 1[J

line 16: [J

line 17: " Set the default highlighting colors.  Use a color scheme if specified.[J

line 18: if exists("colors_name")[J

line 19:   exe "colors " . colors_name[J

line 20: else[J

line 21:   runtime! syntax/syncolor.vim[J

Searching for "syntax/syncolor.vim" in "/home/vimtest/.vim/bundle/vundle,/home/vimtest/.vim/bundle/nerdtree,/home/vimtest/.vim/bundle/vim-rails,/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/,/home/vimtest/.vim/bundle/vim-rails/after,/home/vimtest/.vim/bundle/nerdtree/after,/home/vimtest/.vim/bundle/vundle/after"[J
Searching for "/home/vimtest/.vim/bundle/vundle/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vimfiles/syntax/syncolor.vim"[J
Searching for "/usr/local/share/vim/vim73/syntax/syncolor.vim"[J
chdir(/usr/local/share/vim/vim73/syntax)[J
fchdir() to previous dir[J
line 21: sourcing "/usr/local/share/vim/vim73/syntax/syncolor.vim"[J
line 1: " Vim syntax support file[J

line 2: " Maintainer:^IBram Moolenaar <Bram@vim.org>[J

line 3: " Last Change:^I2001 Sep 12[J

line 4: [J

line 5: " This file sets up the default methods for highlighting.[J

line 6: " It is loaded from "synload.vim" and from Vim for ":syntax reset".[J

line 7: " Also used from init_highlight().[J

line 8: [J

line 9: if !exists("syntax_cmd") || syntax_cmd == "on"[J

line 10:   " ":syntax on" works like in Vim 5.7: set colors but keep links[J

line 11:   command -nargs=* SynColor hi <args>[J

line 12:   command -nargs=* SynLink hi link <args>[J

line 13: else[J

line 14:   if syntax_cmd == "enable"[J

line 15:     " ":syntax enable" keeps any existing colors[J

line 16:     command -nargs=* SynColor hi def <args>[J

line 17:     command -nargs=* SynLink hi def link <args>[J

line 18:   elseif syntax_cmd == "reset"[J

line 19:     " ":syntax reset" resets all colors to the default[J

line 20:     command -nargs=* SynColor hi <args>[J

line 21:     command -nargs=* SynLink hi! link <args>[J

line 22:   else[J

line 23:     " User defined syncolor file has already set the colors.[J

line 24:     finish[J

line 25:   endif[J

line 26: endif[J

line 27: [J

line 28: " Many terminals can only use six different colors (plus black and white).[J

line 29: " Therefore the number of colors used is kept low. It doesn't look nice with[J

line 30: " too many colors anyway.[J

line 31: " Careful with "cterm=bold", it changes the color to bright for some terminals.[J

line 32: " There are two sets of defaults: for a dark and a light background.[J

line 33: if &background == "dark"[J

line 34:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 34: hi def Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE[J

line 35:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 35: hi def Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE[J

line 36:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 36: hi def Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE[J

line 37:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 37: hi def Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE[J

line 38:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 38: hi def Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE[J

line 39:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 39: hi def PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE[J

line 40:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 40: hi def Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE[J

line 41:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 41: hi def Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff[J

line 42:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 42: hi def Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 43: else[J

line 44:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE[J

line 45:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE[J

line 46:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE[J

line 47:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE[J

line 48:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE[J

line 49:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE[J

line 50:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE[J

line 51:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue[J

line 52:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE[J

line 53: endif[J

line 54: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 54: hi def Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red[J

line 55: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 55: hi def Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow[J

line 56: [J

line 57: " Common groups that link to default highlighting.[J

line 58: " You can specify other highlighting easily.[J

line 59: SynLink String^I^IConstant[J

line 59: hi def link String^I^IConstant[J

line 60: SynLink Character^IConstant[J

line 60: hi def link Character^IConstant[J

line 61: SynLink Number^I^IConstant[J

line 61: hi def link Number^I^IConstant[J

line 62: SynLink Boolean^I^IConstant[J

line 62: hi def link Boolean^I^IConstant[J

line 63: SynLink Float^I^INumber[J

line 63: hi def link Float^I^INumber[J

line 64: SynLink Function^IIdentifier[J

line 64: hi def link Function^IIdentifier[J

line 65: SynLink Conditional^IStatement[J

line 65: hi def link Conditional^IStatement[J

line 66: SynLink Repeat^I^IStatement[J

line 66: hi def link Repeat^I^IStatement[J

line 67: SynLink Label^I^IStatement[J

line 67: hi def link Label^I^IStatement[J

line 68: SynLink Operator^IStatement[J

line 68: hi def link Operator^IStatement[J

line 69: SynLink Keyword^I^IStatement[J

line 69: hi def link Keyword^I^IStatement[J

line 70: SynLink Exception^IStatement[J

line 70: hi def link Exception^IStatement[J

line 71: SynLink Include^I^IPreProc[J

line 71: hi def link Include^I^IPreProc[J

line 72: SynLink Define^I^IPreProc[J

line 72: hi def link Define^I^IPreProc[J

line 73: SynLink Macro^I^IPreProc[J

line 73: hi def link Macro^I^IPreProc[J

line 74: SynLink PreCondit^IPreProc[J

line 74: hi def link PreCondit^IPreProc[J

line 75: SynLink StorageClass^IType[J

line 75: hi def link StorageClass^IType[J

line 76: SynLink Structure^IType[J

line 76: hi def link Structure^IType[J

line 77: SynLink Typedef^I^IType[J

line 77: hi def link Typedef^I^IType[J

line 78: SynLink Tag^I^ISpecial[J

line 78: hi def link Tag^I^ISpecial[J

line 79: SynLink SpecialChar^ISpecial[J

line 79: hi def link SpecialChar^ISpecial[J

line 80: SynLink Delimiter^ISpecial[J

line 80: hi def link Delimiter^ISpecial[J

line 81: SynLink SpecialComment^ISpecial[J

line 81: hi def link SpecialComment^ISpecial[J

line 82: SynLink Debug^I^ISpecial[J

line 82: hi def link Debug^I^ISpecial[J

line 83: [J

line 84: delcommand SynColor[J

line 85: delcommand SynLink[J

finished sourcing /usr/local/share/vim/vim73/syntax/syncolor.vim[J
continuing in /usr/local/share/vim/vim73/syntax/synload.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/after/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/after/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/after/syntax/syncolor.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/after/syntax/syncolor.vim"[J
line 22: endif[J

line 23: [J

line 24: " Line continuation is used here, remove 'C' from 'cpoptions'[J

line 25: let s:cpo_save = &cpo[J

line 26: set cpo&vim[J

line 27: [J

line 28: " First remove all old syntax autocommands.[J

line 29: au! Syntax[J

line 30: [J

line 31: au Syntax *^I^Icall s:SynSet()[J

line 32: [J

line 33: fun! s:SynSet()[J

line 59: [J

line 60: [J

line 61: " Handle adding doxygen to other languages (C, C++, C#, IDL)[J

line 66: au Syntax c,cpp,cs,idl if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif[J

line 67: [J

line 68: [J

line 69: " Source the user-specified syntax highlighting file[J

line 70: if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))[J

line 71:   execute "source " . mysyntaxfile[J

line 72: endif[J

line 73: [J

line 74: " Restore 'cpoptions'[J

line 75: let &cpo = s:cpo_save[J

line 76: unlet s:cpo_save[J

finished sourcing /usr/local/share/vim/vim73/syntax/synload.vim[J
continuing in /usr/local/share/vim/vim73/syntax/syntax.vim[J
line 20: [J

line 21: " Load the FileType autocommands if not done yet.[J

line 22: if exists("did_load_filetypes")[J

line 23:   let s:did_ft = 1[J

line 24: else[J

line 25:   filetype on[J

line 26:   let s:did_ft = 0[J

line 27: endif[J

line 28: [J

line 29: " Set up the connection between FileType and Syntax autocommands.[J

line 30: " This makes the syntax automatically set when the file type is detected.[J

line 31: augroup syntaxset[J

line 32:   au! FileType *^Iexe "set syntax=" . expand("<amatch>")[J

line 33: augroup END[J

line 34: [J

line 35: [J

line 36: " Execute the syntax autocommands for the each buffer.[J

line 37: " If the filetype wasn't detected yet, do that now.[J

line 38: " Always do the syntaxset autocommands, for buffers where the 'filetype'[J

line 39: " already was set manually (e.g., help buffers).[J

line 40: doautoall syntaxset FileType[J

line 41: if !s:did_ft[J

line 42:   doautoall filetypedetect BufRead[J

line 43: endif[J

finished sourcing /usr/local/share/vim/vim73/syntax/syntax.vim[J
continuing in /home/vimtest/.vimrc[J
line 23: [J

line 24: set cf  " Enable error files & error jumping.[J

line 25: set clipboard+=unnamed  " Yanks go on clipboard instead.[J

line 26: set history=256  " Number of things to remember in history.[J

line 27: set autowrite  " Writes on make/shell commands[J

line 28: set ruler  " Ruler on[J

line 29: set nu  " Line numbers on[J

line 30: set nowrap  " Line wrapping off[J

line 31: set timeoutlen=250  " Time to wait after ESC (default causes an annoying delay)[J

line 32: " colorscheme vividchalk  " Uncomment this to set a default theme[J

line 33: [J

line 34: " Formatting (some of these are for coding in C and C++)[J

line 35: set ts=2  " Tabs are 2 spaces[J

line 36: set bs=2  " Backspace over everything in insert mode[J

line 37: set shiftwidth=2  " Tabs under smart indent[J

line 38: set nocp incsearch[J

line 39: set cinoptions=:0,p0,t0[J

line 40: set cinwords=if,else,while,do,for,switch,case[J

line 41: set formatoptions=tcqr[J

line 42: set cindent[J

line 43: set autoindent[J

line 44: set smarttab[J

line 45: set expandtab[J

line 46: [J

line 47: " Visual[J

line 48: set showmatch  " Show matching brackets.[J

line 49: set mat=5  " Bracket blinking.[J

line 50: set list[J

line 51: " Show $ at end of line and trailing space as ~[J

line 52: set lcs=tab:\ \ ,eol:$,trail:~,extends:>,precedes:<[J

line 53: set novisualbell  " No blinking .[J

line 54: set noerrorbells  " No noise.[J

line 55: set laststatus=2  " Always show status line.[J

line 56: [J

line 57: " gvim specific[J

line 58: set mousehide  " Hide mouse after chars typed[J

line 59: set mouse=a  " Mouse in all modes[J

line 60: [J

line 61: " Backups & Files[J

line 62: set backup                     " Enable creation of backup file.[J

line 63: set backupdir=~/.vim/backups " Where backups will go.[J

line 64: set directory=~/.vim/tmp     " Where temporary files will go.[J

line 65: [J

finished sourcing $HOME/.vimrc[J
Searching for "plugin/**/*.vim" in "/home/vimtest/.vim/bundle/vundle,/home/vimtest/.vim/bundle/nerdtree,/home/vimtest/.vim/bundle/vim-rails,/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/,/home/vimtest/.vim/bundle/vim-rails/after,/home/vimtest/.vim/bundle/nerdtree/after,/home/vimtest/.vim/bundle/vundle/after"[J
Searching for "/home/vimtest/.vim/bundle/vundle/plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/plugin/**/*.vim"[J
chdir(/home/vimtest/.vim/bundle/nerdtree/plugin)[J
fchdir() to previous dir[J
sourcing "/home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim"[J
line 1: " ============================================================================[J

line 2: " File:        NERD_tree.vim[J

line 3: " Description: vim global plugin that provides a nice tree explorer[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " Last Change: 28 December, 2011[J

line 6: " License:     This program is free software. It comes without any warranty,[J

line 7: "              to the extent permitted by applicable law. You can redistribute[J

line 8: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 11: "[J

line 12: " ============================================================================[J

line 13: let s:NERD_tree_version = '4.2.0'[J

line 14: [J

line 15: " SECTION: Script init stuff {{{1[J

line 16: "============================================================[J

line 17: if exists("loaded_nerd_tree")[J

line 18:     finish[J

line 19: endif[J

line 20: if v:version < 700[J

line 21:     echoerr "NERDTree: this plugin requires vim >= 7. DOWNLOAD IT! You'll thank me later!"[J

line 22:     finish[J

line 23: endif[J

line 24: let loaded_nerd_tree = 1[J

line 25: [J

line 26: "for line continuation - i.e dont want C in &cpo[J

line 27: let s:old_cpo = &cpo[J

line 28: set cpo&vim[J

line 29: [J

line 30: let s:running_windows = has("win16") || has("win32") || has("win64")[J

line 31: [J

line 32: "Function: s:initVariable() function {{{2[J

line 33: "This function is used to initialise a given variable to a given value. The[J

line 34: "variable is only initialised if it does not exist prior[J

line 35: "[J

line 36: "Args:[J

line 37: "var: the name of the var to be initialised[J

line 38: "value: the value to initialise var to[J

line 39: "[J

line 40: "Returns:[J

line 41: "1 if the var is set, 0 otherwise[J

line 42: function! s:initVariable(var, value)[J

line 49: [J

line 50: "SECTION: Init variable calls and other random constants {{{2[J

line 51: call s:initVariable("g:NERDChristmasTree", 1)[J

calling function <SNR>12_initVariable[J('g:NERDChristmasTree', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDChristmasTree = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 52: call s:initVariable("g:NERDTreeAutoCenter", 1)[J

calling function <SNR>12_initVariable[J('g:NERDTreeAutoCenter', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeAutoCenter = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 53: call s:initVariable("g:NERDTreeAutoCenterThreshold", 3)[J

calling function <SNR>12_initVariable[J('g:NERDTreeAutoCenterThreshold', 3)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeAutoCenterThreshold = '3'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 54: call s:initVariable("g:NERDTreeCaseSensitiveSort", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeCaseSensitiveSort', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCaseSensitiveSort = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 55: call s:initVariable("g:NERDTreeChDirMode", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeChDirMode', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeChDirMode = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 56: call s:initVariable("g:NERDTreeMinimalUI", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeMinimalUI', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMinimalUI = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 57: if !exists("g:NERDTreeIgnore")[J

line 58:     let g:NERDTreeIgnore = ['\~$'][J

line 59: endif[J

line 60: call s:initVariable("g:NERDTreeBookmarksFile", expand('$HOME') . '/.NERDTreeBookmarks')[J

calling function <SNR>12_initVariable[J('g:NERDTreeBookmarksFile', '/home/vimtest/.NERDTreeBookmarks')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeBookmarksFile = '/home/vimtest/.NERDTreeBookmarks'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 61: call s:initVariable("g:NERDTreeHighlightCursorline", 1)[J

calling function <SNR>12_initVariable[J('g:NERDTreeHighlightCursorline', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeHighlightCursorline = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 62: call s:initVariable("g:NERDTreeHijackNetrw", 1)[J

calling function <SNR>12_initVariable[J('g:NERDTreeHijackNetrw', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeHijackNetrw = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 63: call s:initVariable("g:NERDTreeMouseMode", 1)[J

calling function <SNR>12_initVariable[J('g:NERDTreeMouseMode', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMouseMode = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 64: call s:initVariable("g:NERDTreeNotificationThreshold", 100)[J

calling function <SNR>12_initVariable[J('g:NERDTreeNotificationThreshold', 100)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeNotificationThreshold = '100'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 65: call s:initVariable("g:NERDTreeQuitOnOpen", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeQuitOnOpen', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeQuitOnOpen = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 66: call s:initVariable("g:NERDTreeShowBookmarks", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeShowBookmarks', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowBookmarks = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 67: call s:initVariable("g:NERDTreeShowFiles", 1)[J

calling function <SNR>12_initVariable[J('g:NERDTreeShowFiles', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowFiles = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 68: call s:initVariable("g:NERDTreeShowHidden", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeShowHidden', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowHidden = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 69: call s:initVariable("g:NERDTreeShowLineNumbers", 0)[J

calling function <SNR>12_initVariable[J('g:NERDTreeShowLineNumbers', 0)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeShowLineNumbers = '0'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 70: call s:initVariable("g:NERDTreeSortDirs", 1)[J

calling function <SNR>12_initVariable[J('g:NERDTreeSortDirs', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeSortDirs = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 71: call s:initVariable("g:NERDTreeDirArrows", !s:running_windows)[J

calling function <SNR>12_initVariable[J('g:NERDTreeDirArrows', 1)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeDirArrows = '1'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 72: [J

line 73: if !exists("g:NERDTreeSortOrder")[J

line 74:     let g:NERDTreeSortOrder = ['\/$', '*', '\.swp$',  '\.bak$', '\~$'][J

line 75: else[J

line 76:     "if there isnt a * in the sort sequence then add one[J

line 77:     if count(g:NERDTreeSortOrder, '*') < 1[J

line 78:         call add(g:NERDTreeSortOrder, '*')[J

line 79:     endif[J

line 80: endif[J

line 81: [J

line 82: "we need to use this number many times for sorting... so we calculate it only[J

line 83: "once here[J

line 84: let s:NERDTreeSortStarIndex = index(g:NERDTreeSortOrder, '*')[J

line 85: [J

line 86: if !exists('g:NERDTreeStatusline')[J

line 87: [J

line 88:     "the exists() crap here is a hack to stop vim spazzing out when[J

line 89:     "loading a session that was created with an open nerd tree. It spazzes[J

line 90:     "because it doesnt store b:NERDTreeRoot (its a b: var, and its a hash)[J

line 91:     let g:NERDTreeStatusline = "%{exists('b:NERDTreeRoot')?b:NERDTreeRoot.path.str():''}"[J

line 92: [J

line 93: endif[J

line 94: call s:initVariable("g:NERDTreeWinPos", "left")[J

calling function <SNR>12_initVariable[J('g:NERDTreeWinPos', 'left')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeWinPos = 'left'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 95: call s:initVariable("g:NERDTreeWinSize", 31)[J

calling function <SNR>12_initVariable[J('g:NERDTreeWinSize', 31)

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeWinSize = '31'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 96: [J

line 97: "init the shell commands that will be used to copy nodes, and remove dir trees[J

line 98: "[J

line 99: "Note: the space after the command is important[J

line 100: if s:running_windows[J

line 101:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rmdir /s /q ')[J

line 102: else[J

line 103:     call s:initVariable("g:NERDTreeRemoveDirCmd", 'rm -rf ')[J

calling function <SNR>12_initVariable[J('g:NERDTreeRemoveDirCmd', 'rm -rf ')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeRemoveDirCmd = 'rm -rf '[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 104:     call s:initVariable("g:NERDTreeCopyCmd", 'cp -r ')[J

calling function <SNR>12_initVariable[J('g:NERDTreeCopyCmd', 'cp -r ')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeCopyCmd = 'cp -r '[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 105: endif[J

line 106: [J

line 107: [J

line 108: "SECTION: Init variable calls for key mappings {{{2[J

line 109: call s:initVariable("g:NERDTreeMapActivateNode", "o")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapActivateNode', 'o')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapActivateNode = 'o'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 110: call s:initVariable("g:NERDTreeMapChangeRoot", "C")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapChangeRoot', 'C')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapChangeRoot = 'C'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 111: call s:initVariable("g:NERDTreeMapChdir", "cd")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapChdir', 'cd')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapChdir = 'cd'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 112: call s:initVariable("g:NERDTreeMapCloseChildren", "X")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapCloseChildren', 'X')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapCloseChildren = 'X'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 113: call s:initVariable("g:NERDTreeMapCloseDir", "x")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapCloseDir', 'x')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapCloseDir = 'x'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 114: call s:initVariable("g:NERDTreeMapDeleteBookmark", "D")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapDeleteBookmark', 'D')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapDeleteBookmark = 'D'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 115: call s:initVariable("g:NERDTreeMapMenu", "m")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapMenu', 'm')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapMenu = 'm'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 116: call s:initVariable("g:NERDTreeMapHelp", "?")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapHelp', '?')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapHelp = '?'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 117: call s:initVariable("g:NERDTreeMapJumpFirstChild", "K")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapJumpFirstChild', 'K')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpFirstChild = 'K'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 118: call s:initVariable("g:NERDTreeMapJumpLastChild", "J")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapJumpLastChild', 'J')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpLastChild = 'J'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 119: call s:initVariable("g:NERDTreeMapJumpNextSibling", "<C-j>")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapJumpNextSibling', '<C-j>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpNextSibling = '<C-j>'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 120: call s:initVariable("g:NERDTreeMapJumpParent", "p")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapJumpParent', 'p')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpParent = 'p'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 121: call s:initVariable("g:NERDTreeMapJumpPrevSibling", "<C-k>")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapJumpPrevSibling', '<C-k>')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpPrevSibling = '<C-k>'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 122: call s:initVariable("g:NERDTreeMapJumpRoot", "P")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapJumpRoot', 'P')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapJumpRoot = 'P'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 123: call s:initVariable("g:NERDTreeMapOpenExpl", "e")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapOpenExpl', 'e')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenExpl = 'e'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 124: call s:initVariable("g:NERDTreeMapOpenInTab", "t")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapOpenInTab', 't')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenInTab = 't'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 125: call s:initVariable("g:NERDTreeMapOpenInTabSilent", "T")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapOpenInTabSilent', 'T')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenInTabSilent = 'T'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 126: call s:initVariable("g:NERDTreeMapOpenRecursively", "O")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapOpenRecursively', 'O')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenRecursively = 'O'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 127: call s:initVariable("g:NERDTreeMapOpenSplit", "i")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapOpenSplit', 'i')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenSplit = 'i'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 128: call s:initVariable("g:NERDTreeMapOpenVSplit", "s")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapOpenVSplit', 's')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapOpenVSplit = 's'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 129: call s:initVariable("g:NERDTreeMapPreview", "g" . NERDTreeMapActivateNode)[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapPreview', 'go')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapPreview = 'go'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 130: call s:initVariable("g:NERDTreeMapPreviewSplit", "g" . NERDTreeMapOpenSplit)[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapPreviewSplit', 'gi')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapPreviewSplit = 'gi'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 131: call s:initVariable("g:NERDTreeMapPreviewVSplit", "g" . NERDTreeMapOpenVSplit)[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapPreviewVSplit', 'gs')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapPreviewVSplit = 'gs'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 132: call s:initVariable("g:NERDTreeMapQuit", "q")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapQuit', 'q')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapQuit = 'q'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 133: call s:initVariable("g:NERDTreeMapRefresh", "r")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapRefresh', 'r')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapRefresh = 'r'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 134: call s:initVariable("g:NERDTreeMapRefreshRoot", "R")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapRefreshRoot', 'R')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapRefreshRoot = 'R'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 135: call s:initVariable("g:NERDTreeMapToggleBookmarks", "B")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapToggleBookmarks', 'B')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleBookmarks = 'B'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 136: call s:initVariable("g:NERDTreeMapToggleFiles", "F")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapToggleFiles', 'F')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleFiles = 'F'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 137: call s:initVariable("g:NERDTreeMapToggleFilters", "f")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapToggleFilters', 'f')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleFilters = 'f'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 138: call s:initVariable("g:NERDTreeMapToggleHidden", "I")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapToggleHidden', 'I')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleHidden = 'I'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 139: call s:initVariable("g:NERDTreeMapToggleZoom", "A")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapToggleZoom', 'A')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapToggleZoom = 'A'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 140: call s:initVariable("g:NERDTreeMapUpdir", "u")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapUpdir', 'u')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapUpdir = 'u'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 141: call s:initVariable("g:NERDTreeMapUpdirKeepOpen", "U")[J

calling function <SNR>12_initVariable[J('g:NERDTreeMapUpdirKeepOpen', 'U')

line 1:     if !exists(a:var)[J

line 2:         exec 'let ' . a:var . ' = ' . "'" . substitute(a:value, "'", "''", "g") . "'"[J

line 2: let g:NERDTreeMapUpdirKeepOpen = 'U'[J

line 3:         return 1[J

function <SNR>12_initVariable returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 142: [J

line 143: "SECTION: Script level variable declaration{{{2[J

line 144: if s:running_windows[J

line 145:     let s:escape_chars =  " `\|\"#%&,?()\*^<>"[J

line 146: else[J

line 147:     let s:escape_chars =  " \\`\|\"#%&,?()\*^<>[]"[J

line 148: endif[J

line 149: let s:NERDTreeBufName = 'NERD_tree_'[J

line 150: [J

line 151: let s:tree_wid = 2[J

line 152: [J

line 153: if g:NERDTreeDirArrows[J

line 154:     let s:tree_markup_reg = '^\([▾▸] \| \+[▾▸] \| \+\)'[J

line 155: else[J

line 156:     let s:tree_markup_reg = '^[ `|]*[\-+~]'[J

line 157: endif[J

line 158: let s:tree_up_dir_line = '.. (up a dir)'[J

line 159: [J

line 160: "the number to add to the nerd tree buffer name to make the buf name unique[J

line 161: let s:next_buffer_number = 1[J

line 162: [J

line 163: " SECTION: Commands {{{1[J

line 164: "============================================================[J

line 165: "init the command that users start the nerd tree with[J

line 166: command! -n=? -complete=dir -bar NERDTree :call s:initNerdTree('<args>')[J

line 167: command! -n=? -complete=dir -bar NERDTreeToggle :call s:toggle('<args>')[J

line 168: command! -n=0 -bar NERDTreeClose :call s:closeTreeIfOpen()[J

line 169: command! -n=1 -complete=customlist,s:completeBookmarks -bar NERDTreeFromBookmark call s:initNerdTree('<args>')[J

line 170: command! -n=0 -bar NERDTreeMirror call s:initNerdTreeMirror()[J

line 171: command! -n=0 -bar NERDTreeFind call s:findAndRevealPath()[J

line 172: command! -n=0 -bar NERDTreeFocus call NERDTreeFocus()[J

line 173: " SECTION: Auto commands {{{1[J

line 174: "============================================================[J

line 175: augroup NERDTree[J

line 176:     "Save the cursor position whenever we close the nerd tree[J

line 177:     exec "autocmd BufWinLeave ". s:NERDTreeBufName ."* call <SID>saveScreenState()"[J

line 177: autocmd BufWinLeave NERD_tree_* call <SID>saveScreenState()[J

line 178: [J

line 179:     "disallow insert mode in the NERDTree[J

line 180:     exec "autocmd BufEnter ". s:NERDTreeBufName ."* stopinsert"[J

line 180: autocmd BufEnter NERD_tree_* stopinsert[J

line 181: augroup END[J

line 182: [J

line 183: if g:NERDTreeHijackNetrw[J

line 184:     augroup NERDTreeHijackNetrw[J

line 185:         autocmd VimEnter * silent! autocmd! FileExplorer[J

line 186:         au BufEnter,VimEnter * call s:checkForBrowse(expand("<amatch>"))[J

line 187:     augroup END[J

line 188: endif[J

line 189: [J

line 190: "SECTION: Classes {{{1[J

line 191: "============================================================[J

line 192: "CLASS: Bookmark {{{2[J

line 193: "============================================================[J

line 194: let s:Bookmark = {}[J

line 195: " FUNCTION: Bookmark.activate() {{{3[J

line 196: function! s:Bookmark.activate(...)[J

line 199: " FUNCTION: Bookmark.AddBookmark(name, path) {{{3[J

line 200: " Class method to add a new bookmark to the list, if a previous bookmark exists[J

line 201: " with the same name, just update the path for that bookmark[J

line 202: function! s:Bookmark.AddBookmark(name, path)[J

line 212: " Function: Bookmark.Bookmarks()   {{{3[J

line 213: " Class method to get all bookmarks. Lazily initializes the bookmarks global[J

line 214: " variable[J

line 215: function! s:Bookmark.Bookmarks()[J

line 221: " Function: Bookmark.BookmarkExistsFor(name)   {{{3[J

line 222: " class method that returns 1 if a bookmark with the given name is found, 0[J

line 223: " otherwise[J

line 224: function! s:Bookmark.BookmarkExistsFor(name)[J

line 232: " Function: Bookmark.BookmarkFor(name)   {{{3[J

line 233: " Class method to get the bookmark that has the given name. {} is return if no[J

line 234: " bookmark is found[J

line 235: function! s:Bookmark.BookmarkFor(name)[J

line 243: " Function: Bookmark.BookmarkNames()   {{{3[J

line 244: " Class method to return an array of all bookmark names[J

line 245: function! s:Bookmark.BookmarkNames()[J

line 252: " FUNCTION: Bookmark.CacheBookmarks(silent) {{{3[J

line 253: " Class method to read all bookmarks from the bookmarks file intialize[J

line 254: " bookmark objects for each one.[J

line 255: "[J

line 256: " Args:[J

line 257: " silent - dont echo an error msg if invalid bookmarks are found[J

line 258: function! s:Bookmark.CacheBookmarks(silent)[J

line 290: " FUNCTION: Bookmark.compareTo(otherbookmark) {{{3[J

line 291: " Compare these two bookmarks for sorting purposes[J

line 292: function! s:Bookmark.compareTo(otherbookmark)[J

line 295: " FUNCTION: Bookmark.ClearAll() {{{3[J

line 296: " Class method to delete all bookmarks.[J

line 297: function! s:Bookmark.ClearAll()[J

line 303: " FUNCTION: Bookmark.delete() {{{3[J

line 304: " Delete this bookmark. If the node for this bookmark is under the current[J

line 305: " root, then recache bookmarks for its Path object[J

line 306: function! s:Bookmark.delete()[J

line 318: " FUNCTION: Bookmark.getNode(searchFromAbsoluteRoot) {{{3[J

line 319: " Gets the treenode for this bookmark[J

line 320: "[J

line 321: " Args:[J

line 322: " searchFromAbsoluteRoot: specifies whether we should search from the current[J

line 323: " tree root, or the highest cached node[J

line 324: function! s:Bookmark.getNode(searchFromAbsoluteRoot)[J

line 332: " FUNCTION: Bookmark.GetNodeForName(name, searchFromAbsoluteRoot) {{{3[J

line 333: " Class method that finds the bookmark with the given name and returns the[J

line 334: " treenode for it.[J

line 335: function! s:Bookmark.GetNodeForName(name, searchFromAbsoluteRoot)[J

line 339: " FUNCTION: Bookmark.GetSelected() {{{3[J

line 340: " returns the Bookmark the cursor is over, or {}[J

line 341: function! s:Bookmark.GetSelected()[J

line 353: [J

line 354: " Function: Bookmark.InvalidBookmarks()   {{{3[J

line 355: " Class method to get all invalid bookmark strings read from the bookmarks[J

line 356: " file[J

line 357: function! s:Bookmark.InvalidBookmarks()[J

line 363: " FUNCTION: Bookmark.mustExist() {{{3[J

line 364: function! s:Bookmark.mustExist()[J

line 371: " FUNCTION: Bookmark.New(name, path) {{{3[J

line 372: " Create a new bookmark object with the given name and path object[J

line 373: function! s:Bookmark.New(name, path)[J

line 383: " FUNCTION: Bookmark.open([options]) {{{3[J

line 384: "Args:[J

line 385: "A dictionary containing the following keys (all optional):[J

line 386: "  'where': Specifies whether the node should be opened in new split/tab or in[J

line 387: "           the previous window. Can be either 'v' (vertical split), 'h'[J

line 388: "           (horizontal split), 't' (new tab) or 'p' (previous window).[J

line 389: "  'reuse': if a window is displaying the file then jump the cursor there[J

line 390: "  'keepopen': dont close the tree window[J

line 391: "  'stay': open the file, but keep the cursor in the tree win[J

line 392: "[J

line 393: function! s:Bookmark.open(...)[J

line 403: " FUNCTION: Bookmark.openInNewTab(options) {{{3[J

line 404: " Create a new bookmark object with the given name and path object[J

line 405: function! s:Bookmark.openInNewTab(options)[J

line 409: " Function: Bookmark.setPath(path)   {{{3[J

line 410: " makes this bookmark point to the given path[J

line 411: function! s:Bookmark.setPath(path)[J

line 414: " Function: Bookmark.Sort()   {{{3[J

line 415: " Class method that sorts all bookmarks[J

line 416: function! s:Bookmark.Sort()[J

line 420: " Function: Bookmark.str()   {{{3[J

line 421: " Get the string that should be rendered in the view for this bookmark[J

line 422: function! s:Bookmark.str()[J

line 434: " FUNCTION: Bookmark.toRoot() {{{3[J

line 435: " Make the node for this bookmark the new tree root[J

line 436: function! s:Bookmark.toRoot()[J

line 448: " FUNCTION: Bookmark.ToRoot(name) {{{3[J

line 449: " Make the node for this bookmark the new tree root[J

line 450: function! s:Bookmark.ToRoot(name)[J

line 454: [J

line 455: [J

line 456: "FUNCTION: Bookmark.validate() {{{3[J

line 457: function! s:Bookmark.validate()[J

line 467: [J

line 468: " Function: Bookmark.Write()   {{{3[J

line 469: " Class method to write all bookmarks to the bookmarks file[J

line 470: function! s:Bookmark.Write()[J

line 484: "CLASS: KeyMap {{{2[J

line 485: "============================================================[J

line 486: let s:KeyMap = {}[J

line 487: "FUNCTION: KeyMap.All() {{{3[J

line 488: function! s:KeyMap.All()[J

line 494: [J

line 495: "FUNCTION: KeyMap.FindFor(key, scope) {{{3[J

line 496: function! s:KeyMap.FindFor(key, scope)[J

line 504: [J

line 505: "FUNCTION: KeyMap.BindAll() {{{3[J

line 506: function! s:KeyMap.BindAll()[J

line 511: [J

line 512: "FUNCTION: KeyMap.bind() {{{3[J

line 513: function! s:KeyMap.bind()[J

line 530: [J

line 531: "FUNCTION: KeyMap.Remove(key, scope) {{{3[J

line 532: function! s:KeyMap.Remove(key, scope)[J

line 540: "FUNCTION: KeyMap.invoke() {{{3[J

line 541: "Call the KeyMaps callback function[J

line 542: function! s:KeyMap.invoke(...)[J

line 550: [J

line 551: [J

line 552: "FUNCTION: KeyMap.Invoke() {{{3[J

line 553: "Find a keymapping for a:key and the current scope invoke it.[J

line 554: "[J

line 555: "Scope is determined as follows:[J

line 556: "   * if the cursor is on a dir node then "DirNode"[J

line 557: "   * if the cursor is on a file node then "FileNode"[J

line 558: "   * if the cursor is on a bookmark then "Bookmark"[J

line 559: "[J

line 560: "If a keymap has the scope of "all" then it will be called if no other keymap[J

line 561: "is found for a:key and the scope.[J

line 562: function! s:KeyMap.Invoke(key)[J

line 605: [J

line 606: "this is needed since I cant figure out how to invoke dict functions from a[J

line 607: "key map[J

line 608: function! s:KeyMap_Invoke(key)[J

line 611: [J

line 612: "FUNCTION: KeyMap.Create(options) {{{3[J

line 613: function! s:KeyMap.Create(options)[J

line 623: [J

line 624: "FUNCTION: KeyMap.Add(keymap) {{{3[J

line 625: function! s:KeyMap.Add(keymap)[J

line 629: [J

line 630: "CLASS: MenuController {{{2[J

line 631: "============================================================[J

line 632: let s:MenuController = {}[J

line 633: "FUNCTION: MenuController.New(menuItems) {{{3[J

line 634: "create a new menu controller that operates on the given menu items[J

line 635: function! s:MenuController.New(menuItems)[J

line 644: [J

line 645: "FUNCTION: MenuController.showMenu() {{{3[J

line 646: "start the main loop of the menu and get the user to choose/execute a menu[J

line 647: "item[J

line 648: function! s:MenuController.showMenu()[J

line 670: [J

line 671: "FUNCTION: MenuController._echoPrompt() {{{3[J

line 672: function! s:MenuController._echoPrompt()[J

line 684: [J

line 685: "FUNCTION: MenuController._current(key) {{{3[J

line 686: "get the MenuItem that is currently selected[J

line 687: function! s:MenuController._current()[J

line 690: [J

line 691: "FUNCTION: MenuController._handleKeypress(key) {{{3[J

line 692: "change the selection (if appropriate) and return 1 if the user has made[J

line 693: "their choice, 0 otherwise[J

line 694: function! s:MenuController._handleKeypress(key)[J

line 716: [J

line 717: "FUNCTION: MenuController._allIndexesFor(shortcut) {{{3[J

line 718: "get indexes to all menu items with the given shortcut[J

line 719: function! s:MenuController._allIndexesFor(shortcut)[J

line 730: [J

line 731: "FUNCTION: MenuController._nextIndexFor(shortcut) {{{3[J

line 732: "get the index to the next menu item with the given shortcut, starts from the[J

line 733: "current cursor location and wraps around to the top again if need be[J

line 734: function! s:MenuController._nextIndexFor(shortcut)[J

line 749: [J

line 750: "FUNCTION: MenuController._setCmdheight() {{{3[J

line 751: "sets &cmdheight to whatever is needed to display the menu[J

line 752: function! s:MenuController._setCmdheight()[J

line 755: [J

line 756: "FUNCTION: MenuController._saveOptions() {{{3[J

line 757: "set any vim options that are required to make the menu work (saving their old[J

line 758: "values)[J

line 759: function! s:MenuController._saveOptions()[J

line 765: [J

line 766: "FUNCTION: MenuController._restoreOptions() {{{3[J

line 767: "restore the options we saved in _saveOptions()[J

line 768: function! s:MenuController._restoreOptions()[J

line 772: [J

line 773: "FUNCTION: MenuController._cursorDown() {{{3[J

line 774: "move the cursor to the next menu item, skipping separators[J

line 775: function! s:MenuController._cursorDown()[J

line 789: [J

line 790: "FUNCTION: MenuController._cursorUp() {{{3[J

line 791: "move the cursor to the previous menu item, skipping separators[J

line 792: function! s:MenuController._cursorUp()[J

line 806: [J

line 807: "CLASS: MenuItem {{{2[J

line 808: "============================================================[J

line 809: let s:MenuItem = {}[J

line 810: "FUNCTION: MenuItem.All() {{{3[J

line 811: "get all top level menu items[J

line 812: function! s:MenuItem.All()[J

line 818: [J

line 819: "FUNCTION: MenuItem.AllEnabled() {{{3[J

line 820: "get all top level menu items that are currently enabled[J

line 821: function! s:MenuItem.AllEnabled()[J

line 830: [J

line 831: "FUNCTION: MenuItem.Create(options) {{{3[J

line 832: "make a new menu item and add it to the global list[J

line 833: function! s:MenuItem.Create(options)[J

line 858: [J

line 859: "FUNCTION: MenuItem.CreateSeparator(options) {{{3[J

line 860: "make a new separator menu item and add it to the global list[J

line 861: function! s:MenuItem.CreateSeparator(options)[J

line 869: [J

line 870: "FUNCTION: MenuItem.CreateSubmenu(options) {{{3[J

line 871: "make a new submenu and add it to global list[J

line 872: function! s:MenuItem.CreateSubmenu(options)[J

line 878: [J

line 879: "FUNCTION: MenuItem.enabled() {{{3[J

line 880: "return 1 if this menu item should be displayed[J

line 881: "[J

line 882: "delegates off to the isActiveCallback, and defaults to 1 if no callback was[J

line 883: "specified[J

line 884: function! s:MenuItem.enabled()[J

line 890: [J

line 891: "FUNCTION: MenuItem.execute() {{{3[J

line 892: "perform the action behind this menu item, if this menuitem has children then[J

line 893: "display a new menu for them, otherwise deletegate off to the menuitem's[J

line 894: "callback[J

line 895: function! s:MenuItem.execute()[J

line 905: [J

line 906: "FUNCTION: MenuItem.isSeparator() {{{3[J

line 907: "return 1 if this menuitem is a separator[J

line 908: function! s:MenuItem.isSeparator()[J

line 911: [J

line 912: "FUNCTION: MenuItem.isSubmenu() {{{3[J

line 913: "return 1 if this menuitem is a submenu[J

line 914: function! s:MenuItem.isSubmenu()[J

line 917: [J

line 918: "CLASS: TreeFileNode {{{2[J

line 919: "This class is the parent of the TreeDirNode class and constitures the[J

line 920: "'Component' part of the composite design pattern between the treenode[J

line 921: "classes.[J

line 922: "============================================================[J

line 923: let s:TreeFileNode = {}[J

line 924: "FUNCTION: TreeFileNode.activate(...) {{{3[J

line 925: function! s:TreeFileNode.activate(...)[J

line 928: "FUNCTION: TreeFileNode.bookmark(name) {{{3[J

line 929: "bookmark this node with a:name[J

line 930: function! s:TreeFileNode.bookmark(name)[J

line 949: "FUNCTION: TreeFileNode.cacheParent() {{{3[J

line 950: "initializes self.parent if it isnt already[J

line 951: function! s:TreeFileNode.cacheParent()[J

line 960: "FUNCTION: TreeFileNode.compareNodes {{{3[J

line 961: "This is supposed to be a class level method but i cant figure out how to[J

line 962: "get func refs to work from a dict..[J

line 963: "[J

line 964: "A class level method that compares two nodes[J

line 965: "[J

line 966: "Args:[J

line 967: "n1, n2: the 2 nodes to compare[J

line 968: function! s:compareNodes(n1, n2)[J

line 971: [J

line 972: "FUNCTION: TreeFileNode.clearBoomarks() {{{3[J

line 973: function! s:TreeFileNode.clearBoomarks()[J

line 981: "FUNCTION: TreeFileNode.copy(dest) {{{3[J

line 982: function! s:TreeFileNode.copy(dest)[J

line 993: [J

line 994: "FUNCTION: TreeFileNode.delete {{{3[J

line 995: "Removes this node from the tree and calls the Delete method for its path obj[J

line 996: function! s:TreeFileNode.delete()[J

line 1000: [J

line 1001: "FUNCTION: TreeFileNode.displayString() {{{3[J

line 1002: "[J

line 1003: "Returns a string that specifies how the node should be represented as a[J

line 1004: "string[J

line 1005: "[J

line 1006: "Return:[J

line 1007: "a string that can be used in the view to represent this node[J

line 1008: function! s:TreeFileNode.displayString()[J

line 1011: [J

line 1012: "FUNCTION: TreeFileNode.equals(treenode) {{{3[J

line 1013: "[J

line 1014: "Compares this treenode to the input treenode and returns 1 if they are the[J

line 1015: "same node.[J

line 1016: "[J

line 1017: "Use this method instead of ==  because sometimes when the treenodes contain[J

line 1018: "many children, vim seg faults when doing ==[J

line 1019: "[J

line 1020: "Args:[J

line 1021: "treenode: the other treenode to compare to[J

line 1022: function! s:TreeFileNode.equals(treenode)[J

line 1025: [J

line 1026: "FUNCTION: TreeFileNode.findNode(path) {{{3[J

line 1027: "Returns self if this node.path.Equals the given path.[J

line 1028: "Returns {} if not equal.[J

line 1029: "[J

line 1030: "Args:[J

line 1031: "path: the path object to compare against[J

line 1032: function! s:TreeFileNode.findNode(path)[J

line 1038: "FUNCTION: TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction) {{{3[J

line 1039: "[J

line 1040: "Finds the next sibling for this node in the indicated direction. This sibling[J

line 1041: "must be a directory and may/may not have children as specified.[J

line 1042: "[J

line 1043: "Args:[J

line 1044: "direction: 0 if you want to find the previous sibling, 1 for the next sibling[J

line 1045: "[J

line 1046: "Return:[J

line 1047: "a treenode object or {} if no appropriate sibling could be found[J

line 1048: function! s:TreeFileNode.findOpenDirSiblingWithVisibleChildren(direction)[J

line 1063: "FUNCTION: TreeFileNode.findSibling(direction) {{{3[J

line 1064: "[J

line 1065: "Finds the next sibling for this node in the indicated direction[J

line 1066: "[J

line 1067: "Args:[J

line 1068: "direction: 0 if you want to find the previous sibling, 1 for the next sibling[J

line 1069: "[J

line 1070: "Return:[J

line 1071: "a treenode object or {} if no sibling could be found[J

line 1072: function! s:TreeFileNode.findSibling(direction)[J

line 1101: [J

line 1102: "FUNCTION: TreeFileNode.getLineNum(){{{3[J

line 1103: "returns the line number this node is rendered on, or -1 if it isnt rendered[J

line 1104: function! s:TreeFileNode.getLineNum()[J

line 1150: [J

line 1151: "FUNCTION: TreeFileNode.GetRootForTab(){{{3[J

line 1152: "get the root node for this tab[J

line 1153: function! s:TreeFileNode.GetRootForTab()[J

line 1159: "FUNCTION: TreeFileNode.GetRootLineNum(){{{3[J

line 1160: "gets the line number of the root node[J

line 1161: function! s:TreeFileNode.GetRootLineNum()[J

line 1168: [J

line 1169: "FUNCTION: TreeFileNode.GetSelected() {{{3[J

line 1170: "gets the treenode that the cursor is currently over[J

line 1171: function! s:TreeFileNode.GetSelected()[J

line 1182: "FUNCTION: TreeFileNode.isVisible() {{{3[J

line 1183: "returns 1 if this node should be visible according to the tree filters and[J

line 1184: "hidden file filters (and their on/off status)[J

line 1185: function! s:TreeFileNode.isVisible()[J

line 1188: "FUNCTION: TreeFileNode.isRoot() {{{3[J

line 1189: "returns 1 if this node is b:NERDTreeRoot[J

line 1190: function! s:TreeFileNode.isRoot()[J

line 1197: [J

line 1198: "FUNCTION: TreeFileNode.makeRoot() {{{3[J

line 1199: "Make this node the root of the tree[J

line 1200: function! s:TreeFileNode.makeRoot()[J

line 1217: "FUNCTION: TreeFileNode.New(path) {{{3[J

line 1218: "Returns a new TreeNode object with the given path and parent[J

line 1219: "[J

line 1220: "Args:[J

line 1221: "path: a path object representing the full filesystem path to the file/dir that the node represents[J

line 1222: function! s:TreeFileNode.New(path)[J

line 1232: [J

line 1233: "FUNCTION: TreeFileNode.open() {{{3[J

line 1234: function! s:TreeFileNode.open(...)[J

line 1239: [J

line 1240: "FUNCTION: TreeFileNode.openSplit() {{{3[J

line 1241: "Open this node in a new window[J

line 1242: function! s:TreeFileNode.openSplit()[J

line 1246: "FUNCTION: TreeFileNode.openVSplit() {{{3[J

line 1247: "Open this node in a new vertical window[J

line 1248: function! s:TreeFileNode.openVSplit()[J

line 1252: "FUNCTION: TreeFileNode.openInNewTab(options) {{{3[J

line 1253: function! s:TreeFileNode.openInNewTab(options)[J

line 1257: "FUNCTION: TreeFileNode.putCursorHere(isJump, recurseUpward){{{3[J

line 1258: "Places the cursor on the line number this node is rendered on[J

line 1259: "[J

line 1260: "Args:[J

line 1261: "isJump: 1 if this cursor movement should be counted as a jump by vim[J

line 1262: "recurseUpward: try to put the cursor on the parent if the this node isnt[J

line 1263: "visible[J

line 1264: function! s:TreeFileNode.putCursorHere(isJump, recurseUpward)[J

line 1283: [J

line 1284: "FUNCTION: TreeFileNode.refresh() {{{3[J

line 1285: function! s:TreeFileNode.refresh()[J

line 1288: "FUNCTION: TreeFileNode.rename() {{{3[J

line 1289: "Calls the rename method for this nodes path obj[J

line 1290: function! s:TreeFileNode.rename(newName)[J

line 1303: "FUNCTION: TreeFileNode.renderToString {{{3[J

line 1304: "returns a string representation for this tree to be rendered in the view[J

line 1305: function! s:TreeFileNode.renderToString()[J

line 1308: [J

line 1309: [J

line 1310: "Args:[J

line 1311: "depth: the current depth in the tree for this call[J

line 1312: "drawText: 1 if we should actually draw the line for this node (if 0 then the[J

line 1313: "child nodes are rendered only)[J

line 1314: "vertMap: a binary array that indicates whether a vertical bar should be draw[J

line 1315: "for each depth in the tree[J

line 1316: "isLastChild:true if this curNode is the last child of its parent[J

line 1317: function! s:TreeFileNode._renderToString(depth, drawText, vertMap, isLastChild)[J

line 1397: "CLASS: TreeDirNode {{{2[J

line 1398: "This class is a child of the TreeFileNode class and constitutes the[J

line 1399: "'Composite' part of the composite design pattern between the treenode[J

line 1400: "classes.[J

line 1401: "============================================================[J

line 1402: let s:TreeDirNode = copy(s:TreeFileNode)[J

line 1403: "FUNCTION: TreeDirNode.AbsoluteTreeRoot(){{{3[J

line 1404: "class method that returns the highest cached ancestor of the current root[J

line 1405: function! s:TreeDirNode.AbsoluteTreeRoot()[J

line 1412: "FUNCTION: TreeDirNode.activate([options]) {{{3[J

line 1413: unlet s:TreeDirNode.activate[J

line 1414: function! s:TreeDirNode.activate(...)[J

line 1420: "FUNCTION: TreeDirNode.addChild(treenode, inOrder) {{{3[J

line 1421: "Adds the given treenode to the list of children for this node[J

line 1422: "[J

line 1423: "Args:[J

line 1424: "-treenode: the node to add[J

line 1425: "-inOrder: 1 if the new node should be inserted in sorted order[J

line 1426: function! s:TreeDirNode.addChild(treenode, inOrder)[J

line 1434: [J

line 1435: "FUNCTION: TreeDirNode.close() {{{3[J

line 1436: "Closes this directory[J

line 1437: function! s:TreeDirNode.close()[J

line 1440: [J

line 1441: "FUNCTION: TreeDirNode.closeChildren() {{{3[J

line 1442: "Closes all the child dir nodes of this node[J

line 1443: function! s:TreeDirNode.closeChildren()[J

line 1451: [J

line 1452: "FUNCTION: TreeDirNode.createChild(path, inOrder) {{{3[J

line 1453: "Instantiates a new child node for this node with the given path. The new[J

line 1454: "nodes parent is set to this node.[J

line 1455: "[J

line 1456: "Args:[J

line 1457: "path: a Path object that this node will represent/contain[J

line 1458: "inOrder: 1 if the new node should be inserted in sorted order[J

line 1459: "[J

line 1460: "Returns:[J

line 1461: "the newly created node[J

line 1462: function! s:TreeDirNode.createChild(path, inOrder)[J

line 1467: [J

line 1468: "FUNCTION: TreeDirNode.findNode(path) {{{3[J

line 1469: "Will find one of the children (recursively) that has the given path[J

line 1470: "[J

line 1471: "Args:[J

line 1472: "path: a path object[J

line 1473: unlet s:TreeDirNode.findNode[J

line 1474: function! s:TreeDirNode.findNode(path)[J

line 1492: "FUNCTION: TreeDirNode.getChildCount() {{{3[J

line 1493: "Returns the number of children this node has[J

line 1494: function! s:TreeDirNode.getChildCount()[J

line 1497: [J

line 1498: "FUNCTION: TreeDirNode.getChild(path) {{{3[J

line 1499: "Returns child node of this node that has the given path or {} if no such node[J

line 1500: "exists.[J

line 1501: "[J

line 1502: "This function doesnt not recurse into child dir nodes[J

line 1503: "[J

line 1504: "Args:[J

line 1505: "path: a path object[J

line 1506: function! s:TreeDirNode.getChild(path)[J

line 1519: [J

line 1520: "FUNCTION: TreeDirNode.getChildByIndex(indx, visible) {{{3[J

line 1521: "returns the child at the given index[J

line 1522: "Args:[J

line 1523: "indx: the index to get the child from[J

line 1524: "visible: 1 if only the visible children array should be used, 0 if all the[J

line 1525: "children should be searched.[J

line 1526: function! s:TreeDirNode.getChildByIndex(indx, visible)[J

line 1533: [J

line 1534: "FUNCTION: TreeDirNode.getChildIndex(path) {{{3[J

line 1535: "Returns the index of the child node of this node that has the given path or[J

line 1536: "-1 if no such node exists.[J

line 1537: "[J

line 1538: "This function doesnt not recurse into child dir nodes[J

line 1539: "[J

line 1540: "Args:[J

line 1541: "path: a path object[J

line 1542: function! s:TreeDirNode.getChildIndex(path)[J

line 1564: [J

line 1565: "FUNCTION: TreeDirNode.GetSelected() {{{3[J

line 1566: "Returns the current node if it is a dir node, or else returns the current[J

line 1567: "nodes parent[J

line 1568: unlet s:TreeDirNode.GetSelected[J

line 1569: function! s:TreeDirNode.GetSelected()[J

line 1578: "FUNCTION: TreeDirNode.getVisibleChildCount() {{{3[J

line 1579: "Returns the number of visible children this node has[J

line 1580: function! s:TreeDirNode.getVisibleChildCount()[J

line 1583: [J

line 1584: "FUNCTION: TreeDirNode.getVisibleChildren() {{{3[J

line 1585: "Returns a list of children to display for this node, in the correct order[J

line 1586: "[J

line 1587: "Return:[J

line 1588: "an array of treenodes[J

line 1589: function! s:TreeDirNode.getVisibleChildren()[J

line 1598: [J

line 1599: "FUNCTION: TreeDirNode.hasVisibleChildren() {{{3[J

line 1600: "returns 1 if this node has any childre, 0 otherwise..[J

line 1601: function! s:TreeDirNode.hasVisibleChildren()[J

line 1604: [J

line 1605: "FUNCTION: TreeDirNode._initChildren() {{{3[J

line 1606: "Removes all childen from this node and re-reads them[J

line 1607: "[J

line 1608: "Args:[J

line 1609: "silent: 1 if the function should not echo any "please wait" messages for[J

line 1610: "large directories[J

line 1611: "[J

line 1612: "Return: the number of child nodes read[J

line 1613: function! s:TreeDirNode._initChildren(silent)[J

line 1656: "FUNCTION: TreeDirNode.New(path) {{{3[J

line 1657: "Returns a new TreeNode object with the given path and parent[J

line 1658: "[J

line 1659: "Args:[J

line 1660: "path: a path object representing the full filesystem path to the file/dir that the node represents[J

line 1661: unlet s:TreeDirNode.New[J

line 1662: function! s:TreeDirNode.New(path)[J

line 1677: "FUNCTION: TreeDirNode.open([opts]) {{{3[J

line 1678: "Open the dir in the current tree or in a new tree elsewhere.[J

line 1679: "[J

line 1680: "If opening in the current tree, return the number of cached nodes.[J

line 1681: unlet s:TreeDirNode.open[J

line 1682: function! s:TreeDirNode.open(...)[J

line 1697: [J

line 1698: " FUNCTION: TreeDirNode.openExplorer() {{{3[J

line 1699: " opens an explorer window for this node in the previous window (could be a[J

line 1700: " nerd tree or a netrw)[J

line 1701: function! s:TreeDirNode.openExplorer()[J

line 1704: "FUNCTION: TreeDirNode.openInNewTab(options) {{{3[J

line 1705: unlet s:TreeDirNode.openInNewTab[J

line 1706: function! s:TreeDirNode.openInNewTab(options)[J

line 1710: "FUNCTION: TreeDirNode._openInNewTab() {{{3[J

line 1711: function! s:TreeDirNode._openInNewTab()[J

line 1715: "FUNCTION: TreeDirNode.openRecursively() {{{3[J

line 1716: "Opens this treenode and all of its children whose paths arent 'ignored'[J

line 1717: "because of the file filters.[J

line 1718: "[J

line 1719: "This method is actually a wrapper for the OpenRecursively2 method which does[J

line 1720: "the work.[J

line 1721: function! s:TreeDirNode.openRecursively()[J

line 1724: [J

line 1725: "FUNCTION: TreeDirNode._openRecursively2() {{{3[J

line 1726: "Opens this all children of this treenode recursively if either:[J

line 1727: "   *they arent filtered by file filters[J

line 1728: "   *a:forceOpen is 1[J

line 1729: "[J

line 1730: "Args:[J

line 1731: "forceOpen: 1 if this node should be opened regardless of file filters[J

line 1732: function! s:TreeDirNode._openRecursively2(forceOpen)[J

line 1746: [J

line 1747: "FUNCTION: TreeDirNode.refresh() {{{3[J

line 1748: unlet s:TreeDirNode.refresh[J

line 1749: function! s:TreeDirNode.refresh()[J

line 1798: [J

line 1799: "FUNCTION: TreeDirNode.reveal(path) {{{3[J

line 1800: "reveal the given path, i.e. cache and open all treenodes needed to display it[J

line 1801: "in the UI[J

line 1802: function! s:TreeDirNode.reveal(path)[J

line 1824: "FUNCTION: TreeDirNode.removeChild(treenode) {{{3[J

line 1825: "[J

line 1826: "Removes the given treenode from this nodes set of children[J

line 1827: "[J

line 1828: "Args:[J

line 1829: "treenode: the node to remove[J

line 1830: "[J

line 1831: "Throws a NERDTree.ChildNotFoundError if the given treenode is not found[J

line 1832: function! s:TreeDirNode.removeChild(treenode)[J

line 1842: [J

line 1843: "FUNCTION: TreeDirNode.sortChildren() {{{3[J

line 1844: "[J

line 1845: "Sorts the children of this node according to alphabetical order and the[J

line 1846: "directory priority.[J

line 1847: "[J

line 1848: function! s:TreeDirNode.sortChildren()[J

line 1852: [J

line 1853: "FUNCTION: TreeDirNode.toggleOpen([options]) {{{3[J

line 1854: "Opens this directory if it is closed and vice versa[J

line 1855: function! s:TreeDirNode.toggleOpen(...)[J

line 1863: [J

line 1864: "FUNCTION: TreeDirNode.transplantChild(newNode) {{{3[J

line 1865: "Replaces the child of this with the given node (where the child node's full[J

line 1866: "path matches a:newNode's fullpath). The search for the matching node is[J

line 1867: "non-recursive[J

line 1868: "[J

line 1869: "Arg:[J

line 1870: "newNode: the node to graft into the tree[J

line 1871: function! s:TreeDirNode.transplantChild(newNode)[J

line 1880: "============================================================[J

line 1881: "CLASS: Opener {{{2[J

line 1882: "============================================================[J

line 1883: let s:Opener = {}[J

line 1884: [J

line 1885: "FUNCTION: Opener._checkToCloseTree(newtab) {{{3[J

line 1886: "Check the class options and global options (i.e. NERDTreeQuitOnOpen) to see[J

line 1887: "if the tree should be closed now.[J

line 1888: "[J

line 1889: "Args:[J

line 1890: "a:newtab - boolean. If set, only close the tree now if we are opening the[J

line 1891: "target in a new tab. This is needed because we have to close tree before we[J

line 1892: "leave the tab[J

line 1893: function! s:Opener._checkToCloseTree(newtab)[J

line 1902: [J

line 1903: "FUNCTION: Opener._gotoTargetWin() {{{3[J

line 1904: function! s:Opener._gotoTargetWin()[J

line 1929: [J

line 1930: "FUNCTION: Opener.New(path, opts) {{{3[J

line 1931: "Args:[J

line 1932: "[J

line 1933: "a:path: The path object that is to be opened.[J

line 1934: "[J

line 1935: "a:opts:[J

line 1936: "[J

line 1937: "A dictionary containing the following keys (all optional):[J

line 1938: "  'where': Specifies whether the node should be opened in new split/tab or in[J

line 1939: "           the previous window. Can be either 'v' or 'h' or 't' (for open in[J

line 1940: "           new tab)[J

line 1941: "  'reuse': if a window is displaying the file then jump the cursor there[J

line 1942: "  'keepopen': dont close the tree window[J

line 1943: "  'stay': open the file, but keep the cursor in the tree win[J

line 1944: function! s:Opener.New(path, opts)[J

line 1957: [J

line 1958: "FUNCTION: Opener._newSplit() {{{3[J

line 1959: function! s:Opener._newSplit()[J

line 2017: [J

line 2018: "FUNCTION: Opener._newVSplit() {{{3[J

line 2019: function! s:Opener._newVSplit()[J

line 2033: [J

line 2034: "FUNCTION: Opener.open(target) {{{3[J

line 2035: function! s:Opener.open(target)[J

line 2042: [J

line 2043: "FUNCTION: Opener._openFile() {{{3[J

line 2044: function! s:Opener._openFile()[J

line 2062: [J

line 2063: "FUNCTION: Opener._openDirectory(node) {{{3[J

line 2064: function! s:Opener._openDirectory(node)[J

line 2085: [J

line 2086: "FUNCTION: Opener._previousWindow() {{{3[J

line 2087: function! s:Opener._previousWindow()[J

line 2105: [J

line 2106: "FUNCTION: Opener._restoreCursorPos(){{{3[J

line 2107: function! s:Opener._restoreCursorPos()[J

line 2111: [J

line 2112: "FUNCTION: Opener._reuseWindow(){{{3[J

line 2113: "put the cursor in the first window we find for this file[J

line 2114: "[J

line 2115: "return 1 if we were successful[J

line 2116: function! s:Opener._reuseWindow()[J

line 2136: [J

line 2137: "FUNCTION: Opener._saveCursorPos(){{{3[J

line 2138: function! s:Opener._saveCursorPos()[J

line 2142: [J

line 2143: "CLASS: Path {{{2[J

line 2144: "============================================================[J

line 2145: let s:Path = {}[J

line 2146: "FUNCTION: Path.AbsolutePathFor(str) {{{3[J

line 2147: function! s:Path.AbsolutePathFor(str)[J

line 2162: "FUNCTION: Path.bookmarkNames() {{{3[J

line 2163: function! s:Path.bookmarkNames()[J

line 2169: "FUNCTION: Path.cacheDisplayString() {{{3[J

line 2170: function! s:Path.cacheDisplayString()[J

line 2195: "FUNCTION: Path.changeToDir() {{{3[J

line 2196: function! s:Path.changeToDir()[J

line 2209: [J

line 2210: "FUNCTION: Path.compareTo() {{{3[J

line 2211: "[J

line 2212: "Compares this Path to the given path and returns 0 if they are equal, -1 if[J

line 2213: "this Path is "less than" the given path, or 1 if it is "greater".[J

line 2214: "[J

line 2215: "Args:[J

line 2216: "path: the path object to compare this to[J

line 2217: "[J

line 2218: "Return:[J

line 2219: "1, -1 or 0[J

line 2220: function! s:Path.compareTo(path)[J

line 2249: [J

line 2250: "FUNCTION: Path.Create(fullpath) {{{3[J

line 2251: "[J

line 2252: "Factory method.[J

line 2253: "[J

line 2254: "Creates a path object with the given path. The path is also created on the[J

line 2255: "filesystem. If the path already exists, a NERDTree.Path.Exists exception is[J

line 2256: "thrown. If any other errors occur, a NERDTree.Path exception is thrown.[J

line 2257: "[J

line 2258: "Args:[J

line 2259: "fullpath: the full filesystem path to the file/dir to create[J

line 2260: function! s:Path.Create(fullpath)[J

line 2285: [J

line 2286: "FUNCTION: Path.copy(dest) {{{3[J

line 2287: "[J

line 2288: "Copies the file/dir represented by this Path to the given location[J

line 2289: "[J

line 2290: "Args:[J

line 2291: "dest: the location to copy this dir/file to[J

line 2292: function! s:Path.copy(dest)[J

line 2305: [J

line 2306: "FUNCTION: Path.CopyingSupported() {{{3[J

line 2307: "[J

line 2308: "returns 1 if copying is supported for this OS[J

line 2309: function! s:Path.CopyingSupported()[J

line 2312: [J

line 2313: [J

line 2314: "FUNCTION: Path.copyingWillOverwrite(dest) {{{3[J

line 2315: "[J

line 2316: "returns 1 if copy this path to the given location will cause files to[J

line 2317: "overwritten[J

line 2318: "[J

line 2319: "Args:[J

line 2320: "dest: the location this path will be copied to[J

line 2321: function! s:Path.copyingWillOverwrite(dest)[J

line 2333: [J

line 2334: "FUNCTION: Path.delete() {{{3[J

line 2335: "[J

line 2336: "Deletes the file represented by this path.[J

line 2337: "Deletion of directories is not supported[J

line 2338: "[J

line 2339: "Throws NERDTree.Path.Deletion exceptions[J

line 2340: function! s:Path.delete()[J

line 2362: [J

line 2363: "FUNCTION: Path.displayString() {{{3[J

line 2364: "[J

line 2365: "Returns a string that specifies how the path should be represented as a[J

line 2366: "string[J

line 2367: function! s:Path.displayString()[J

line 2374: "FUNCTION: Path.edit() {{{3[J

line 2375: function! s:Path.edit()[J

line 2378: "FUNCTION: Path.extractDriveLetter(fullpath) {{{3[J

line 2379: "[J

line 2380: "If running windows, cache the drive letter for this path[J

line 2381: function! s:Path.extractDriveLetter(fullpath)[J

line 2395: "FUNCTION: Path.exists() {{{3[J

line 2396: "return 1 if this path points to a location that is readable or is a directory[J

line 2397: function! s:Path.exists()[J

line 2401: "FUNCTION: Path.getDir() {{{3[J

line 2402: "[J

line 2403: "Returns this path if it is a directory, else this paths parent.[J

line 2404: "[J

line 2405: "Return:[J

line 2406: "a Path object[J

line 2407: function! s:Path.getDir()[J

line 2414: "FUNCTION: Path.getParent() {{{3[J

line 2415: "[J

line 2416: "Returns a new path object for this paths parent[J

line 2417: "[J

line 2418: "Return:[J

line 2419: "a new Path object[J

line 2420: function! s:Path.getParent()[J

line 2429: "FUNCTION: Path.getLastPathComponent(dirSlash) {{{3[J

line 2430: "[J

line 2431: "Gets the last part of this path.[J

line 2432: "[J

line 2433: "Args:[J

line 2434: "dirSlash: if 1 then a trailing slash will be added to the returned value for[J

line 2435: "directory nodes.[J

line 2436: function! s:Path.getLastPathComponent(dirSlash)[J

line 2446: [J

line 2447: "FUNCTION: Path.getSortOrderIndex() {{{3[J

line 2448: "returns the index of the pattern in g:NERDTreeSortOrder that this path matches[J

line 2449: function! s:Path.getSortOrderIndex()[J

line 2459: [J

line 2460: "FUNCTION: Path.ignore() {{{3[J

line 2461: "returns true if this path should be ignored[J

line 2462: function! s:Path.ignore()[J

line 2487: [J

line 2488: "FUNCTION: Path._ignorePatternMatches(pattern) {{{3[J

line 2489: "returns true if this path matches the given ignore pattern[J

line 2490: function! s:Path._ignorePatternMatches(pattern)[J

line 2506: "FUNCTION: Path.isUnder(path) {{{3[J

line 2507: "return 1 if this path is somewhere under the given path in the filesystem.[J

line 2508: "[J

line 2509: "a:path should be a dir[J

line 2510: function! s:Path.isUnder(path)[J

line 2519: [J

line 2520: "FUNCTION: Path.JoinPathStrings(...) {{{3[J

line 2521: function! s:Path.JoinPathStrings(...)[J

line 2528: [J

line 2529: "FUNCTION: Path.equals() {{{3[J

line 2530: "[J

line 2531: "Determines whether 2 path objects are "equal".[J

line 2532: "They are equal if the paths they represent are the same[J

line 2533: "[J

line 2534: "Args:[J

line 2535: "path: the other path obj to compare this with[J

line 2536: function! s:Path.equals(path)[J

line 2539: [J

line 2540: "FUNCTION: Path.New() {{{3[J

line 2541: "The Constructor for the Path object[J

line 2542: function! s:Path.New(path)[J

line 2551: [J

line 2552: "FUNCTION: Path.Slash() {{{3[J

line 2553: "return the slash to use for the current OS[J

line 2554: function! s:Path.Slash()[J

line 2557: [J

line 2558: "FUNCTION: Path.Resolve() {{{3[J

line 2559: "Invoke the vim resolve() function and return the result[J

line 2560: "This is necessary because in some versions of vim resolve() removes trailing[J

line 2561: "slashes while in other versions it doesn't.  This always removes the trailing[J

line 2562: "slash[J

line 2563: function! s:Path.Resolve(path)[J

line 2567: [J

line 2568: "FUNCTION: Path.readInfoFromDisk(fullpath) {{{3[J

line 2569: "[J

line 2570: "[J

line 2571: "Throws NERDTree.Path.InvalidArguments exception.[J

line 2572: function! s:Path.readInfoFromDisk(fullpath)[J

line 2621: [J

line 2622: "FUNCTION: Path.refresh() {{{3[J

line 2623: function! s:Path.refresh()[J

line 2627: [J

line 2628: "FUNCTION: Path.rename() {{{3[J

line 2629: "[J

line 2630: "Renames this node on the filesystem[J

line 2631: function! s:Path.rename(newPath)[J

line 2648: [J

line 2649: "FUNCTION: Path.str() {{{3[J

line 2650: "[J

line 2651: "Returns a string representation of this Path[J

line 2652: "[J

line 2653: "Takes an optional dictionary param to specify how the output should be[J

line 2654: "formatted.[J

line 2655: "[J

line 2656: "The dict may have the following keys:[J

line 2657: "  'format'[J

line 2658: "  'escape'[J

line 2659: "  'truncateTo'[J

line 2660: "[J

line 2661: "The 'format' key may have a value of:[J

line 2662: "  'Cd' - a string to be used with the :cd command[J

line 2663: "  'Edit' - a string to be used with :e :sp :new :tabedit etc[J

line 2664: "  'UI' - a string used in the NERD tree UI[J

line 2665: "[J

line 2666: "The 'escape' key, if specified will cause the output to be escaped with[J

line 2667: "shellescape()[J

line 2668: "[J

line 2669: "The 'truncateTo' key causes the resulting string to be truncated to the value[J

line 2670: "'truncateTo' maps to. A '<' char will be prepended.[J

line 2671: function! s:Path.str(...)[J

line 2699: [J

line 2700: "FUNCTION: Path._strForUI() {{{3[J

line 2701: function! s:Path._strForUI()[J

line 2708: [J

line 2709: "FUNCTION: Path._strForCd() {{{3[J

line 2710: "[J

line 2711: " returns a string that can be used with :cd[J

line 2712: function! s:Path._strForCd()[J

line 2715: "FUNCTION: Path._strForEdit() {{{3[J

line 2716: "[J

line 2717: "Return: the string for this path that is suitable to be used with the :edit[J

line 2718: "command[J

line 2719: function! s:Path._strForEdit()[J

line 2747: "FUNCTION: Path._strForGlob() {{{3[J

line 2748: function! s:Path._strForGlob()[J

line 2763: "FUNCTION: Path._str() {{{3[J

line 2764: "[J

line 2765: "Gets the string path for this path object that is appropriate for the OS.[J

line 2766: "EG, in windows c:\foo\bar[J

line 2767: "    in *nix  /foo/bar[J

line 2768: function! s:Path._str()[J

line 2778: [J

line 2779: "FUNCTION: Path.strTrunk() {{{3[J

line 2780: "Gets the path without the last segment on the end.[J

line 2781: function! s:Path.strTrunk()[J

line 2784: [J

line 2785: " FUNCTION: Path.tabnr() {{{3[J

line 2786: " return the number of the first tab that is displaying this file[J

line 2787: "[J

line 2788: " return 0 if no tab was found[J

line 2789: function! s:Path.tabnr()[J

line 2800: "FUNCTION: Path.WinToUnixPath(pathstr){{{3[J

line 2801: "Takes in a windows path and returns the unix equiv[J

line 2802: "[J

line 2803: "A class level method[J

line 2804: "[J

line 2805: "Args:[J

line 2806: "pathstr: the windows path to convert[J

line 2807: function! s:Path.WinToUnixPath(pathstr)[J

line 2825: [J

line 2826: " SECTION: General Functions {{{1[J

line 2827: "============================================================[J

line 2828: "FUNCTION: s:bufInWindows(bnum){{{2[J

line 2829: "[[STOLEN FROM VTREEEXPLORER.VIM]][J

line 2830: "Determine the number of windows open to this buffer number.[J

line 2831: "Care of Yegappan Lakshman.  Thanks![J

line 2832: "[J

line 2833: "Args:[J

line 2834: "bnum: the subject buffers buffer number[J

line 2835: function! s:bufInWindows(bnum)[J

line 2851: "FUNCTION: s:checkForBrowse(dir) {{{2[J

line 2852: "inits a secondary nerd tree in the current buffer if appropriate[J

line 2853: function! s:checkForBrowse(dir)[J

line 2858: "FUNCTION: s:compareBookmarks(first, second) {{{2[J

line 2859: "Compares two bookmarks[J

line 2860: function! s:compareBookmarks(first, second)[J

line 2863: [J

line 2864: " FUNCTION: s:completeBookmarks(A,L,P) {{{2[J

line 2865: " completion function for the bookmark commands[J

line 2866: function! s:completeBookmarks(A,L,P)[J

line 2869: " FUNCTION: s:createDefaultBindings() {{{2[J

line 2870: function! s:createDefaultBindings()[J

line 2942: " FUNCTION: s:deprecated(func, [msg]) {{{2[J

line 2943: " Issue a deprecation warning for a:func. If a second arg is given, use this[J

line 2944: " as the deprecation message[J

line 2945: function! s:deprecated(func, ...)[J

line 2956: " FUNCTION: s:exec(cmd) {{{2[J

line 2957: " same as :exec cmd  but eventignore=all is set for the duration[J

line 2958: function! s:exec(cmd)[J

line 2964: " FUNCTION: s:findAndRevealPath() {{{2[J

line 2965: function! s:findAndRevealPath()[J

line 2998: [J

line 2999: " FUNCTION: s:has_opt(options, name) {{{2[J

line 3000: function! s:has_opt(options, name)[J

line 3003: [J

line 3004: "FUNCTION: s:initNerdTree(name) {{{2[J

line 3005: "Initialise the nerd tree for this tab. The tree will start in either the[J

line 3006: "given directory, or the directory associated with the given bookmark[J

line 3007: "[J

line 3008: "Args:[J

line 3009: "name: the name of a bookmark or a directory[J

line 3010: function! s:initNerdTree(name)[J

line 3064: [J

line 3065: "FUNCTION: s:initNerdTreeInPlace(dir) {{{2[J

line 3066: function! s:initNerdTreeInPlace(dir)[J

line 3095: " FUNCTION: s:initNerdTreeMirror() {{{2[J

line 3096: function! s:initNerdTreeMirror()[J

line 3148: " FUNCTION: s:nextBufferName() {{{2[J

line 3149: " returns the buffer name for the next nerd tree[J

line 3150: function! s:nextBufferName()[J

line 3155: " FUNCTION: s:postSourceActions() {{{2[J

line 3156: function! s:postSourceActions()[J

line 3163: " FUNCTION: s:tabpagevar(tabnr, var) {{{2[J

line 3164: function! s:tabpagevar(tabnr, var)[J

line 3180: " Function: s:treeExistsForBuffer()   {{{2[J

line 3181: " Returns 1 if a nerd tree root exists in the current buffer[J

line 3182: function! s:treeExistsForBuf()[J

line 3185: " Function: s:treeExistsForTab()   {{{2[J

line 3186: " Returns 1 if a nerd tree root exists in the current tab[J

line 3187: function! s:treeExistsForTab()[J

line 3190: " Function: s:SID()   {{{2[J

line 3191: function s:SID()[J

line 3197: "FUNCTION: s:upDir(keepState) {{{2[J

line 3198: "moves the tree up a level[J

line 3199: "[J

line 3200: "Args:[J

line 3201: "keepState: 1 if the current root should be left open when the tree is[J

line 3202: "re-rendered[J

line 3203: function! s:upDir(keepState)[J

line 3232: " Function: s:unique(list)   {{{2[J

line 3233: " returns a:list without duplicates[J

line 3234: function! s:unique(list)[J

line 3243: " SECTION: Public API {{{1[J

line 3244: "============================================================[J

line 3245: let g:NERDTreePath = s:Path[J

line 3246: let g:NERDTreeDirNode = s:TreeDirNode[J

line 3247: let g:NERDTreeFileNode = s:TreeFileNode[J

line 3248: let g:NERDTreeBookmark = s:Bookmark[J

line 3249: [J

line 3250: function! NERDTreeAddMenuItem(options)[J

line 3253: [J

line 3254: function! NERDTreeAddMenuSeparator(...)[J

line 3258: [J

line 3259: function! NERDTreeAddSubmenu(options)[J

line 3262: [J

line 3263: function! NERDTreeAddKeyMap(options)[J

line 3266: [J

line 3267: function! NERDTreeRender()[J

line 3270: [J

line 3271: function! NERDTreeFocus()[J

line 3278: [J

line 3279: " SECTION: View Functions {{{1[J

line 3280: "============================================================[J

line 3281: "FUNCTION: s:centerView() {{{2[J

line 3282: "centers the nerd tree window around the cursor (provided the nerd tree[J

line 3283: "options permit)[J

line 3284: function! s:centerView()[J

line 3294: "FUNCTION: s:closeTree() {{{2[J

line 3295: "Closes the primary NERD tree window for this tab[J

line 3296: function! s:closeTree()[J

line 3317: [J

line 3318: "FUNCTION: s:closeTreeIfOpen() {{{2[J

line 3319: "Closes the NERD tree window if it is open[J

line 3320: function! s:closeTreeIfOpen()[J

line 3325: "FUNCTION: s:closeTreeIfQuitOnOpen() {{{2[J

line 3326: "Closes the NERD tree window if the close on open option is set[J

line 3327: function! s:closeTreeIfQuitOnOpen()[J

line 3332: "FUNCTION: s:createTreeWin() {{{2[J

line 3333: "Inits the NERD tree window. ie. opens it, sizes it, sets all the local[J

line 3334: "options etc[J

line 3335: function! s:createTreeWin()[J

line 3352: [J

line 3353: "FUNCTION: s:dumpHelp  {{{2[J

line 3354: "prints out the quick help[J

line 3355: function! s:dumpHelp()[J

line 3458: "FUNCTION: s:echo  {{{2[J

line 3459: "A wrapper for :echo. Appends 'NERDTree:' on the front of all messages[J

line 3460: "[J

line 3461: "Args:[J

line 3462: "msg: the message to echo[J

line 3463: function! s:echo(msg)[J

line 3467: "FUNCTION: s:echoWarning {{{2[J

line 3468: "Wrapper for s:echo, sets the message type to warningmsg for this message[J

line 3469: "Args:[J

line 3470: "msg: the message to echo[J

line 3471: function! s:echoWarning(msg)[J

line 3476: "FUNCTION: s:echoError {{{2[J

line 3477: "Wrapper for s:echo, sets the message type to errormsg for this message[J

line 3478: "Args:[J

line 3479: "msg: the message to echo[J

line 3480: function! s:echoError(msg)[J

line 3485: "FUNCTION: s:firstUsableWindow(){{{2[J

line 3486: "find the window number of the first normal window[J

line 3487: function! s:firstUsableWindow()[J

line 3501: "FUNCTION: s:getPath(ln) {{{2[J

line 3502: "Gets the full path to the node that is rendered on the given line number[J

line 3503: "[J

line 3504: "Args:[J

line 3505: "ln: the line number to get the path for[J

line 3506: "[J

line 3507: "Return:[J

line 3508: "A path if a node was selected, {} if nothing is selected.[J

line 3509: "If the 'up a dir' line was selected then the path to the parent of the[J

line 3510: "current root is returned[J

line 3511: function! s:getPath(ln)[J

line 3569: [J

line 3570: "FUNCTION: s:getTreeWinNum() {{{2[J

line 3571: "gets the nerd tree window number for this tab[J

line 3572: function! s:getTreeWinNum()[J

line 3579: "FUNCTION: s:indentLevelFor(line) {{{2[J

line 3580: function! s:indentLevelFor(line)[J

line 3589: "FUNCTION: s:isTreeOpen() {{{2[J

line 3590: function! s:isTreeOpen()[J

line 3593: "FUNCTION: s:isWindowUsable(winnumber) {{{2[J

line 3594: "Returns 0 if opening a file from the tree in the given window requires it to[J

line 3595: "be split, 1 otherwise[J

line 3596: "[J

line 3597: "Args:[J

line 3598: "winnumber: the number of the window in question[J

line 3599: function! s:isWindowUsable(winnumber)[J

line 3623: [J

line 3624: " FUNCTION: s:jumpToChild(direction) {{{2[J

line 3625: " Args:[J

line 3626: " direction: 0 if going to first child, 1 if going to last[J

line 3627: function! s:jumpToChild(currentNode, direction)[J

line 3651: [J

line 3652: [J

line 3653: " FUNCTION: s:jumpToSibling(currentNode, forward) {{{2[J

line 3654: " moves the cursor to the sibling of the current node in the given direction[J

line 3655: "[J

line 3656: " Args:[J

line 3657: " forward: 1 if the cursor should move to the next sibling, 0 if it should[J

line 3658: " move back to the previous sibling[J

line 3659: function! s:jumpToSibling(currentNode, forward)[J

line 3667: [J

line 3668: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{2[J

line 3669: "prints out the given msg and, if the user responds by pushing 'y' then the[J

line 3670: "buffer with the given bufnum is deleted[J

line 3671: "[J

line 3672: "Args:[J

line 3673: "bufnum: the buffer that may be deleted[J

line 3674: "msg: a message that will be echoed to the user asking them if they wish to[J

line 3675: "     del the buffer[J

line 3676: function! s:promptToDelBuffer(bufnum, msg)[J

line 3682: [J

line 3683: "FUNCTION: s:putCursorOnBookmarkTable(){{{2[J

line 3684: "Places the cursor at the top of the bookmarks table[J

line 3685: function! s:putCursorOnBookmarkTable()[J

line 3705: [J

line 3706: "FUNCTION: s:putCursorInTreeWin(){{{2[J

line 3707: "Places the cursor in the nerd tree window[J

line 3708: function! s:putCursorInTreeWin()[J

line 3715: [J

line 3716: "FUNCTION: s:renderBookmarks {{{2[J

line 3717: function! s:renderBookmarks()[J

line 3732: "FUNCTION: s:renderView {{{2[J

line 3733: "The entry function for rendering the tree[J

line 3734: function! s:renderView()[J

line 3788: [J

line 3789: "FUNCTION: s:renderViewSavingPosition {{{2[J

line 3790: "Renders the tree and ensures the cursor stays on the current node or the[J

line 3791: "current nodes parent if it is no longer available upon re-rendering[J

line 3792: function! s:renderViewSavingPosition()[J

line 3807: "FUNCTION: s:restoreScreenState() {{{2[J

line 3808: "[J

line 3809: "Sets the screen state back to what it was when s:saveScreenState was last[J

line 3810: "called.[J

line 3811: "[J

line 3812: "Assumes the cursor is in the NERDTree window[J

line 3813: function! s:restoreScreenState()[J

line 3826: [J

line 3827: "FUNCTION: s:saveScreenState() {{{2[J

line 3828: "Saves the current cursor position in the current buffer and the window[J

line 3829: "scroll position[J

line 3830: function! s:saveScreenState()[J

line 3841: [J

line 3842: "FUNCTION: s:setCommonBufOptions() {{{2[J

line 3843: function! s:setCommonBufOptions()[J

line 3880: [J

line 3881: "FUNCTION: s:setupStatusline() {{{2[J

line 3882: function! s:setupStatusline()[J

line 3887: "FUNCTION: s:stripMarkupFromLine(line, removeLeadingSpaces){{{2[J

line 3888: "returns the given line with all the tree parts stripped off[J

line 3889: "[J

line 3890: "Args:[J

line 3891: "line: the subject line[J

line 3892: "removeLeadingSpaces: 1 if leading spaces are to be removed (leading spaces =[J

line 3893: "any spaces before the actual text of the node)[J

line 3894: function! s:stripMarkupFromLine(line, removeLeadingSpaces)[J

line 3923: [J

line 3924: "FUNCTION: s:toggle(dir) {{{2[J

line 3925: "Toggles the NERD tree. I.e the NERD tree is open, it is closed, if it is[J

line 3926: "closed it is restored or initialized (if it doesnt exist)[J

line 3927: "[J

line 3928: "Args:[J

line 3929: "dir: the full path for the root node (is only used if the NERD tree is being[J

line 3930: "initialized.[J

line 3931: function! s:toggle(dir)[J

line 3946: "SECTION: Interface bindings {{{1[J

line 3947: "============================================================[J

line 3948: [J

line 3949: "FUNCTION: s:activateAll() {{{2[J

line 3950: "handle the user activating the updir line[J

line 3951: function! s:activateAll()[J

line 3956: [J

line 3957: "FUNCTION: s:activateDirNode() {{{2[J

line 3958: "handle the user activating a tree node[J

line 3959: function! s:activateDirNode(node)[J

line 3962: [J

line 3963: "FUNCTION: s:activateFileNode() {{{2[J

line 3964: "handle the user activating a tree node[J

line 3965: function! s:activateFileNode(node)[J

line 3968: [J

line 3969: "FUNCTION: s:activateBookmark() {{{2[J

line 3970: "handle the user activating a bookmark[J

line 3971: function! s:activateBookmark(bm)[J

line 3974: [J

line 3975: "FUNCTION: s:bindMappings() {{{2[J

line 3976: function! s:bindMappings()[J

line 3991: [J

line 3992: " FUNCTION: s:bookmarkNode(name) {{{2[J

line 3993: " Associate the current node with the given name[J

line 3994: function! s:bookmarkNode(...)[J

line 4011: [J

line 4012: " FUNCTION: s:chCwd(node) {{{2[J

line 4013: function! s:chCwd(node)[J

line 4020: [J

line 4021: " FUNCTION: s:chRoot(node) {{{2[J

line 4022: " changes the current root to the selected one[J

line 4023: function! s:chRoot(node)[J

line 4028: [J

line 4029: " FUNCTION: s:clearBookmarks(bookmarks) {{{2[J

line 4030: function! s:clearBookmarks(bookmarks)[J

line 4044: " FUNCTION: s:closeChildren(node) {{{2[J

line 4045: " closes all childnodes of the current node[J

line 4046: function! s:closeChildren(node)[J

line 4051: " FUNCTION: s:closeCurrentDir(node) {{{2[J

line 4052: " closes the parent dir of the current node[J

line 4053: function! s:closeCurrentDir(node)[J

line 4063: " FUNCTION: s:closeTreeWindow() {{{2[J

line 4064: " close the tree window[J

line 4065: function! s:closeTreeWindow()[J

line 4076: " FUNCTION: s:deleteBookmark(bm) {{{2[J

line 4077: " if the cursor is on a bookmark, prompt to delete[J

line 4078: function! s:deleteBookmark(bm)[J

line 4094: [J

line 4095: " FUNCTION: s:displayHelp() {{{2[J

line 4096: " toggles the help display[J

line 4097: function! s:displayHelp()[J

line 4102: [J

line 4103: "FUNCTION: s:handleLeftClick() {{{2[J

line 4104: "Checks if the click should open the current node[J

line 4105: function! s:handleLeftClick()[J

line 4138: [J

line 4139: " FUNCTION: s:handleMiddleMouse() {{{2[J

line 4140: function! s:handleMiddleMouse()[J

line 4153: [J

line 4154: " FUNCTION: s:jumpToFirstChild() {{{2[J

line 4155: " wrapper for the jump to child method[J

line 4156: function! s:jumpToFirstChild(node)[J

line 4159: [J

line 4160: " FUNCTION: s:jumpToLastChild() {{{2[J

line 4161: " wrapper for the jump to child method[J

line 4162: function! s:jumpToLastChild(node)[J

line 4165: [J

line 4166: " FUNCTION: s:jumpToParent(node) {{{2[J

line 4167: " moves the cursor to the parent of the current node[J

line 4168: function! s:jumpToParent(node)[J

line 4176: [J

line 4177: " FUNCTION: s:jumpToRoot() {{{2[J

line 4178: " moves the cursor to the root node[J

line 4179: function! s:jumpToRoot()[J

line 4183: [J

line 4184: " FUNCTION: s:jumpToNextSibling(node) {{{2[J

line 4185: function! s:jumpToNextSibling(node)[J

line 4188: [J

line 4189: " FUNCTION: s:jumpToPrevSibling(node) {{{2[J

line 4190: function! s:jumpToPrevSibling(node)[J

line 4193: [J

line 4194: " FUNCTION: s:openBookmark(name) {{{2[J

line 4195: " put the cursor on the given bookmark and, if its a file, open it[J

line 4196: function! s:openBookmark(name)[J

line 4212: [J

line 4213: " FUNCTION: s:openHSplit(target) {{{2[J

line 4214: function! s:openHSplit(target)[J

line 4217: [J

line 4218: " FUNCTION: s:openVSplit(target) {{{2[J

line 4219: function! s:openVSplit(target)[J

line 4222: [J

line 4223: " FUNCTION: s:openExplorer(node) {{{2[J

line 4224: function! s:openExplorer(node)[J

line 4227: [J

line 4228: " FUNCTION: s:openInNewTab(target) {{{2[J

line 4229: function! s:openInNewTab(target)[J

line 4232: [J

line 4233: " FUNCTION: s:openInNewTabSilent(target) {{{2[J

line 4234: function! s:openInNewTabSilent(target)[J

line 4237: [J

line 4238: " FUNCTION: s:openNodeRecursively(node) {{{2[J

line 4239: function! s:openNodeRecursively(node)[J

line 4246: [J

line 4247: "FUNCTION: s:previewNodeCurrent(node) {{{2[J

line 4248: function! s:previewNodeCurrent(node)[J

line 4251: [J

line 4252: "FUNCTION: s:previewNodeHSplit(node) {{{2[J

line 4253: function! s:previewNodeHSplit(node)[J

line 4256: [J

line 4257: "FUNCTION: s:previewNodeVSplit(node) {{{2[J

line 4258: function! s:previewNodeVSplit(node)[J

line 4261: [J

line 4262: " FUNCTION: s:revealBookmark(name) {{{2[J

line 4263: " put the cursor on the node associate with the given name[J

line 4264: function! s:revealBookmark(name)[J

line 4272: " FUNCTION: s:refreshRoot() {{{2[J

line 4273: " Reloads the current root. All nodes below this will be lost and the root dir[J

line 4274: " will be reloaded.[J

line 4275: function! s:refreshRoot()[J

line 4282: [J

line 4283: " FUNCTION: s:refreshCurrent(node) {{{2[J

line 4284: " refreshes the root for the current node[J

line 4285: function! s:refreshCurrent(node)[J

line 4297: " FUNCTION: s:showMenu(node) {{{2[J

line 4298: function! s:showMenu(node)[J

line 4302: [J

line 4303: " FUNCTION: s:toggleIgnoreFilter() {{{2[J

line 4304: " toggles the use of the NERDTreeIgnore option[J

line 4305: function! s:toggleIgnoreFilter()[J

line 4310: [J

line 4311: " FUNCTION: s:toggleShowBookmarks() {{{2[J

line 4312: " toggles the display of bookmarks[J

line 4313: function! s:toggleShowBookmarks()[J

line 4323: " FUNCTION: s:toggleShowFiles() {{{2[J

line 4324: " toggles the display of hidden files[J

line 4325: function! s:toggleShowFiles()[J

line 4330: [J

line 4331: " FUNCTION: s:toggleShowHidden() {{{2[J

line 4332: " toggles the display of hidden files[J

line 4333: function! s:toggleShowHidden()[J

line 4338: [J

line 4339: " FUNCTION: s:toggleZoom() {{{2[J

line 4340: " zoom (maximize/minimize) the NERDTree window[J

line 4341: function! s:toggleZoom()[J

line 4351: [J

line 4352: " FUNCTION: s:upDirCurrentRootOpen() {{{2[J

line 4353: function! s:upDirCurrentRootOpen()[J

line 4356: [J

line 4357: " FUNCTION: s:upDirCurrentRootClosed() {{{2[J

line 4358: function! s:upDirCurrentRootClosed()[J

line 4361: [J

line 4362: " SECTION: Post Source Actions {{{1[J

line 4363: call s:postSourceActions()[J

calling function <SNR>12_postSourceActions[J()

line 1:     call s:Bookmark.CacheBookmarks(0)[J

calling function <SNR>12_postSourceActions..9[J(0)

line 1:     if filereadable(g:NERDTreeBookmarksFile)[J

line 2:         let g:NERDTreeBookmarks = [][J

line 3:         let g:NERDTreeInvalidBookmarks = [][J

line 4:         let bookmarkStrings = readfile(g:NERDTreeBookmarksFile)[J

line 5:         let invalidBookmarksFound = 0[J

line 6:         for i in bookmarkStrings[J

line 7: [J

line 8:             "ignore blank lines[J

line 9:             if i != ''[J

line 10: [J

line 11:                 let name = substitute(i, '^\(.\{-}\) .*$', '\1', '')[J

line 12:                 let path = substitute(i, '^.\{-} \(.*\)$', '\1', '')[J

line 13: [J

line 14:                 try[J

line 15:                     let bookmark = s:Bookmark.New(name, s:Path.New(path))[J

line 16:                     call add(g:NERDTreeBookmarks, bookmark)[J

line 17:                 catch /^NERDTree.InvalidArgumentsError/[J

line 18:                     call add(g:NERDTreeInvalidBookmarks, i)[J

line 19:                     let invalidBookmarksFound += 1[J

line 20:                 endtry[J

line 21:             endif[J

line 22:         endfor[J

line 23:         if invalidBookmarksFound[J

line 24:             call s:Bookmark.Write()[J

line 25:             if !a:silent[J

line 26:                 call s:echo(invalidBookmarksFound . " invalid bookmarks were read. See :help NERDTreeInvalidBookmarks for info.")[J

line 27:             endif[J

line 28:         endif[J

line 29:         call s:Bookmark.Sort()[J

line 30:     endif[J

function <SNR>12_postSourceActions..9 returning #0[J

continuing in function <SNR>12_postSourceActions[J

line 2:     call s:createDefaultBindings()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J()

line 1:     let s = '<SNR>' . s:SID() . '_'[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..<SNR>12_SID[J()

line 1:     if !exists("s:sid")[J

line 2:         let s:sid = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')[J

line 3:     endif[J

line 4:     return s:sid[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..<SNR>12_SID returning '12'[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 2: [J

line 3:     call NERDTreeAddKeyMap({ 'key': '<MiddleRelease>', 'scope': "all", 'callback': s."handleMiddleMouse" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<MiddleRelease>', 'scope': '...'callback': '<SNR>12_handleMiddleMouse'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<MiddleRelease>', 'scope': '...'callback': '<SNR>12_handleMiddleMouse'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...eMiddleMouse', 'key': '<MiddleRelease>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<MiddleRelease>', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 4:     call NERDTreeAddKeyMap({ 'key': '<LeftRelease>', 'scope': "all", 'callback': s."handleLeftClick" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<LeftRelease>', 'scope': 'al..., 'callback': '<SNR>12_handleLeftClick'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<LeftRelease>', 'scope': 'al..., 'callback': '<SNR>12_handleLeftClick'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...andleLeftClick', 'key': '<LeftRelease>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<LeftRelease>', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...MiddleMouse', 'key': '<MiddleRelease>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...MiddleMouse', 'key': '<MiddleRelease>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 5:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "DirNode", 'callback': s."activateDirNode" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Di..., 'callback': '<SNR>12_activateDirNode'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<2-LeftMouse>', 'scope': 'Di..., 'callback': '<SNR>12_activateDirNode'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ctivateDirNode', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<2-LeftMouse>', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ndleLeftClick', 'key': '<LeftRelease>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ndleLeftClick', 'key': '<LeftRelease>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 6:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "FileNode", 'callback': s."activateFileNode" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Fi... 'callback': '<SNR>12_activateFileNode'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<2-LeftMouse>', 'scope': 'Fi... 'callback': '<SNR>12_activateFileNode'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...tivateFileNode', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<2-LeftMouse>', 'FileNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...tivateDirNode', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...tivateDirNode', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 7:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "Bookmark", 'callback': s."activateBookmark" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'Bo... 'callback': '<SNR>12_activateBookmark'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<2-LeftMouse>', 'scope': 'Bo... 'callback': '<SNR>12_activateBookmark'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...tivateBookmark', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<2-LeftMouse>', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ivateFileNode', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ivateFileNode', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 8:     call NERDTreeAddKeyMap({ 'key': '<2-LeftMouse>', 'scope': "all", 'callback': s."activateAll" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<2-LeftMouse>', 'scope': 'al...all', 'callback': '<SNR>12_activateAll'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<2-LeftMouse>', 'scope': 'al...all', 'callback': '<SNR>12_activateAll'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...12_activateAll', 'key': '<2-LeftMouse>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<2-LeftMouse>', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ivateBookmark', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ivateBookmark', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 9: [J

line 10: [J

line 11:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "DirNode", 'callback': s."activateDirNode" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'DirNode', 'cal..., 'callback': '<SNR>12_activateDirNode'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'o', 'scope': 'DirNode', 'cal..., 'callback': '<SNR>12_activateDirNode'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...: '<SNR>12_activateDirNode', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('o', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...2_activateAll', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...2_activateAll', 'key': '<2-LeftMouse>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 12:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "FileNode", 'callback': s."activateFileNode" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'FileNode', 'ca... 'callback': '<SNR>12_activateFileNode'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'o', 'scope': 'FileNode', 'ca... 'callback': '<SNR>12_activateFileNode'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu... '<SNR>12_activateFileNode', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('o', 'FileNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_activateDirNode', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_activateDirNode', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 13:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "Bookmark", 'callback': s."activateBookmark" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'Bookmark', 'ca... 'callback': '<SNR>12_activateBookmark'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'o', 'scope': 'Bookmark', 'ca... 'callback': '<SNR>12_activateBookmark'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu... '<SNR>12_activateBookmark', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('o', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_activateFileNode', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_activateFileNode', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 14:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapActivateNode, 'scope': "all", 'callback': s."activateAll" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'o', 'scope': 'all', 'callbac...all', 'callback': '<SNR>12_activateAll'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'o', 'scope': 'all', 'callbac...all', 'callback': '<SNR>12_activateAll'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ack': '<SNR>12_activateAll', 'key': 'o'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('o', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_activateBookmark', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_activateBookmark', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 15: [J

line 16:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Node", 'callback': s."openHSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'i', 'scope': 'Node', 'callba...Node', 'callback': '<SNR>12_openHSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'i', 'scope': 'Node', 'callba...Node', 'callback': '<SNR>12_openHSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...back': '<SNR>12_openHSplit', 'key': 'i'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('i', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ck': '<SNR>12_activateAll', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ck': '<SNR>12_activateAll', 'key': 'o'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 17:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Node", 'callback': s."openVSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 's', 'scope': 'Node', 'callba...Node', 'callback': '<SNR>12_openVSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 's', 'scope': 'Node', 'callba...Node', 'callback': '<SNR>12_openVSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...back': '<SNR>12_openVSplit', 'key': 's'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('s', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openHSplit', 'key': 'i'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openHSplit', 'key': 'i'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 18: [J

line 19:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenSplit, 'scope': "Bookmark", 'callback': s."openHSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'i', 'scope': 'Bookmark', 'ca...mark', 'callback': '<SNR>12_openHSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'i', 'scope': 'Bookmark', 'ca...mark', 'callback': '<SNR>12_openHSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...back': '<SNR>12_openHSplit', 'key': 'i'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('i', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openVSplit', 'key': 's'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openVSplit', 'key': 's'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 20:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenVSplit, 'scope': "Bookmark", 'callback': s."openVSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 's', 'scope': 'Bookmark', 'ca...mark', 'callback': '<SNR>12_openVSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 's', 'scope': 'Bookmark', 'ca...mark', 'callback': '<SNR>12_openVSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...back': '<SNR>12_openVSplit', 'key': 's'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('s', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openHSplit', 'key': 'i'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openHSplit', 'key': 'i'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 21: [J

line 22:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Node", 'callback': s."previewNodeCurrent" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'go', 'scope': 'Node', 'callb...callback': '<SNR>12_previewNodeCurrent'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'go', 'scope': 'Node', 'callb...callback': '<SNR>12_previewNodeCurrent'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...SNR>12_previewNodeCurrent', 'key': 'go'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('go', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openVSplit', 'key': 's'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_openVSplit', 'key': 's'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 23:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Node", 'callback': s."previewNodeVSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'gs', 'scope': 'Node', 'callb...'callback': '<SNR>12_previewNodeVSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'gs', 'scope': 'Node', 'callb...'callback': '<SNR>12_previewNodeVSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_previewNodeVSplit', 'key': 'gs'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('gs', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...NR>12_previewNodeCurrent', 'key': 'go'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...NR>12_previewNodeCurrent', 'key': 'go'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 24:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Node", 'callback': s."previewNodeHSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'gi', 'scope': 'Node', 'callb...'callback': '<SNR>12_previewNodeHSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'gi', 'scope': 'Node', 'callb...'callback': '<SNR>12_previewNodeHSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_previewNodeHSplit', 'key': 'gi'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('gi', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeVSplit', 'key': 'gs'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeVSplit', 'key': 'gs'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 25: [J

line 26:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreview, 'scope': "Bookmark", 'callback': s."previewNodeCurrent" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'go', 'scope': 'Bookmark', 'c...callback': '<SNR>12_previewNodeCurrent'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'go', 'scope': 'Bookmark', 'c...callback': '<SNR>12_previewNodeCurrent'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...SNR>12_previewNodeCurrent', 'key': 'go'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('go', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeHSplit', 'key': 'gi'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeHSplit', 'key': 'gi'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 27:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewVSplit, 'scope': "Bookmark", 'callback': s."previewNodeVSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'gs', 'scope': 'Bookmark', 'c...'callback': '<SNR>12_previewNodeVSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'gs', 'scope': 'Bookmark', 'c...'callback': '<SNR>12_previewNodeVSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_previewNodeVSplit', 'key': 'gs'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('gs', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...NR>12_previewNodeCurrent', 'key': 'go'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...NR>12_previewNodeCurrent', 'key': 'go'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 28:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapPreviewSplit, 'scope': "Bookmark", 'callback': s."previewNodeHSplit" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'gi', 'scope': 'Bookmark', 'c...'callback': '<SNR>12_previewNodeHSplit'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'gi', 'scope': 'Bookmark', 'c...'callback': '<SNR>12_previewNodeHSplit'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_previewNodeHSplit', 'key': 'gi'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('gi', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeVSplit', 'key': 'gs'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeVSplit', 'key': 'gs'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 29: [J

line 30:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenRecursively, 'scope': "DirNode", 'callback': s."openNodeRecursively" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'O', 'scope': 'DirNode', 'cal...allback': '<SNR>12_openNodeRecursively'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'O', 'scope': 'DirNode', 'cal...allback': '<SNR>12_openNodeRecursively'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...SNR>12_openNodeRecursively', 'key': 'O'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('O', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeHSplit', 'key': 'gi'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_previewNodeHSplit', 'key': 'gi'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 31: [J

line 32:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdir, 'scope': "all", 'callback': s."upDirCurrentRootClosed" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'u', 'scope': 'all', 'callbac...back': '<SNR>12_upDirCurrentRootClosed'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'u', 'scope': 'all', 'callbac...back': '<SNR>12_upDirCurrentRootClosed'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...>12_upDirCurrentRootClosed', 'key': 'u'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('u', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...NR>12_openNodeRecursively', 'key': 'O'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...NR>12_openNodeRecursively', 'key': 'O'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 33:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapUpdirKeepOpen, 'scope': "all", 'callback': s."upDirCurrentRootOpen" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'U', 'scope': 'all', 'callbac...llback': '<SNR>12_upDirCurrentRootOpen'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'U', 'scope': 'all', 'callbac...llback': '<SNR>12_upDirCurrentRootOpen'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...NR>12_upDirCurrentRootOpen', 'key': 'U'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('U', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...12_upDirCurrentRootClosed', 'key': 'u'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...12_upDirCurrentRootClosed', 'key': 'u'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 34:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChangeRoot, 'scope': "Node", 'callback': s."chRoot" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'C', 'scope': 'Node', 'callba...': 'Node', 'callback': '<SNR>12_chRoot'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'C', 'scope': 'Node', 'callba...': 'Node', 'callback': '<SNR>12_chRoot'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...callback': '<SNR>12_chRoot', 'key': 'C'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('C', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...R>12_upDirCurrentRootOpen', 'key': 'U'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...R>12_upDirCurrentRootOpen', 'key': 'U'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 35: [J

line 36:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapChdir, 'scope': "Node", 'callback': s."chCwd" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'cd', 'scope': 'Node', 'callb...e': 'Node', 'callback': '<SNR>12_chCwd'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'cd', 'scope': 'Node', 'callb...e': 'Node', 'callback': '<SNR>12_chCwd'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...callback': '<SNR>12_chCwd', 'key': 'cd'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('cd', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...allback': '<SNR>12_chRoot', 'key': 'C'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...allback': '<SNR>12_chRoot', 'key': 'C'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 37: [J

line 38:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapQuit, 'scope': "all", 'callback': s."closeTreeWindow" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'q', 'scope': 'all', 'callbac..., 'callback': '<SNR>12_closeTreeWindow'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'q', 'scope': 'all', 'callbac..., 'callback': '<SNR>12_closeTreeWindow'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...: '<SNR>12_closeTreeWindow', 'key': 'q'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('q', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...allback': '<SNR>12_chCwd', 'key': 'cd'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...allback': '<SNR>12_chCwd', 'key': 'cd'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 39: [J

line 40:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefreshRoot, 'scope': "all", 'callback': s."refreshRoot" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'R', 'scope': 'all', 'callbac...all', 'callback': '<SNR>12_refreshRoot'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'R', 'scope': 'all', 'callbac...all', 'callback': '<SNR>12_refreshRoot'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ack': '<SNR>12_refreshRoot', 'key': 'R'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('R', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_closeTreeWindow', 'key': 'q'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_closeTreeWindow', 'key': 'q'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 41:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapRefresh, 'scope': "Node", 'callback': s."refreshCurrent" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'r', 'scope': 'Node', 'callba...', 'callback': '<SNR>12_refreshCurrent'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'r', 'scope': 'Node', 'callba...', 'callback': '<SNR>12_refreshCurrent'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...': '<SNR>12_refreshCurrent', 'key': 'r'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('r', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ck': '<SNR>12_refreshRoot', 'key': 'R'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ck': '<SNR>12_refreshRoot', 'key': 'R'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 42: [J

line 43:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapHelp, 'scope': "all", 'callback': s."displayHelp" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '?', 'scope': 'all', 'callbac...all', 'callback': '<SNR>12_displayHelp'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '?', 'scope': 'all', 'callbac...all', 'callback': '<SNR>12_displayHelp'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ack': '<SNR>12_displayHelp', 'key': '?'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('?', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...: '<SNR>12_refreshCurrent', 'key': 'r'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...: '<SNR>12_refreshCurrent', 'key': 'r'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 44:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleZoom, 'scope': "all", 'callback': s."toggleZoom" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'A', 'scope': 'all', 'callbac...'all', 'callback': '<SNR>12_toggleZoom'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'A', 'scope': 'all', 'callbac...'all', 'callback': '<SNR>12_toggleZoom'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...back': '<SNR>12_toggleZoom', 'key': 'A'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('A', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ck': '<SNR>12_displayHelp', 'key': '?'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ck': '<SNR>12_displayHelp', 'key': '?'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 45:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleHidden, 'scope': "all", 'callback': s."toggleShowHidden" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'I', 'scope': 'all', 'callbac... 'callback': '<SNR>12_toggleShowHidden'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'I', 'scope': 'all', 'callbac... 'callback': '<SNR>12_toggleShowHidden'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu... '<SNR>12_toggleShowHidden', 'key': 'I'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('I', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_toggleZoom', 'key': 'A'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_toggleZoom', 'key': 'A'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 46:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFilters, 'scope': "all", 'callback': s."toggleIgnoreFilter" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'f', 'scope': 'all', 'callbac...callback': '<SNR>12_toggleIgnoreFilter'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'f', 'scope': 'all', 'callbac...callback': '<SNR>12_toggleIgnoreFilter'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_toggleIgnoreFilter', 'key': 'f'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('f', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_toggleShowHidden', 'key': 'I'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_toggleShowHidden', 'key': 'I'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 47:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleFiles, 'scope': "all", 'callback': s."toggleShowFiles" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'F', 'scope': 'all', 'callbac..., 'callback': '<SNR>12_toggleShowFiles'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'F', 'scope': 'all', 'callbac..., 'callback': '<SNR>12_toggleShowFiles'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...: '<SNR>12_toggleShowFiles', 'key': 'F'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('F', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_toggleIgnoreFilter', 'key': 'f'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_toggleIgnoreFilter', 'key': 'f'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 48:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapToggleBookmarks, 'scope': "all", 'callback': s."toggleShowBookmarks" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'B', 'scope': 'all', 'callbac...allback': '<SNR>12_toggleShowBookmarks'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'B', 'scope': 'all', 'callbac...allback': '<SNR>12_toggleShowBookmarks'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...SNR>12_toggleShowBookmarks', 'key': 'B'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('B', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_toggleShowFiles', 'key': 'F'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_toggleShowFiles', 'key': 'F'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 49: [J

line 50:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseDir, 'scope': "Node", 'callback': s."closeCurrentDir" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'x', 'scope': 'Node', 'callba..., 'callback': '<SNR>12_closeCurrentDir'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'x', 'scope': 'Node', 'callba..., 'callback': '<SNR>12_closeCurrentDir'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...: '<SNR>12_closeCurrentDir', 'key': 'x'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('x', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...NR>12_toggleShowBookmarks', 'key': 'B'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...NR>12_toggleShowBookmarks', 'key': 'B'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 51:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapCloseChildren, 'scope': "DirNode", 'callback': s."closeChildren" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'X', 'scope': 'DirNode', 'cal...e', 'callback': '<SNR>12_closeChildren'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'X', 'scope': 'DirNode', 'cal...e', 'callback': '<SNR>12_closeChildren'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...k': '<SNR>12_closeChildren', 'key': 'X'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('X', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_closeCurrentDir', 'key': 'x'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_closeCurrentDir', 'key': 'x'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 52: [J

line 53:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapMenu, 'scope': "Node", 'callback': s."showMenu" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'm', 'scope': 'Node', 'callba... 'Node', 'callback': '<SNR>12_showMenu'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'm', 'scope': 'Node', 'callba... 'Node', 'callback': '<SNR>12_showMenu'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...llback': '<SNR>12_showMenu', 'key': 'm'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('m', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...': '<SNR>12_closeChildren', 'key': 'X'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...': '<SNR>12_closeChildren', 'key': 'X'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 54: [J

line 55:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpParent, 'scope': "Node", 'callback': s."jumpToParent" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'p', 'scope': 'Node', 'callba...de', 'callback': '<SNR>12_jumpToParent'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'p', 'scope': 'Node', 'callba...de', 'callback': '<SNR>12_jumpToParent'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ck': '<SNR>12_jumpToParent', 'key': 'p'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('p', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...lback': '<SNR>12_showMenu', 'key': 'm'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...lback': '<SNR>12_showMenu', 'key': 'm'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 56:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpFirstChild, 'scope': "Node", 'callback': s."jumpToFirstChild" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'K', 'scope': 'Node', 'callba... 'callback': '<SNR>12_jumpToFirstChild'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'K', 'scope': 'Node', 'callba... 'callback': '<SNR>12_jumpToFirstChild'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu... '<SNR>12_jumpToFirstChild', 'key': 'K'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('K', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_jumpToParent', 'key': 'p'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_jumpToParent', 'key': 'p'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 57:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpLastChild, 'scope': "Node", 'callback': s."jumpToLastChild" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'J', 'scope': 'Node', 'callba..., 'callback': '<SNR>12_jumpToLastChild'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'J', 'scope': 'Node', 'callba..., 'callback': '<SNR>12_jumpToLastChild'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...: '<SNR>12_jumpToLastChild', 'key': 'J'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('J', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_jumpToFirstChild', 'key': 'K'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...'<SNR>12_jumpToFirstChild', 'key': 'K'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 58:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpRoot, 'scope': "all", 'callback': s."jumpToRoot" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'P', 'scope': 'all', 'callbac...'all', 'callback': '<SNR>12_jumpToRoot'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'P', 'scope': 'all', 'callbac...'all', 'callback': '<SNR>12_jumpToRoot'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...back': '<SNR>12_jumpToRoot', 'key': 'P'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('P', 'all')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_jumpToLastChild', 'key': 'J'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f... '<SNR>12_jumpToLastChild', 'key': 'J'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 59:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpNextSibling, 'scope': "Node", 'callback': s."jumpToNextSibling" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<C-j>', 'scope': 'Node', 'ca...'callback': '<SNR>12_jumpToNextSibling'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<C-j>', 'scope': 'Node', 'ca...'callback': '<SNR>12_jumpToNextSibling'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...R>12_jumpToNextSibling', 'key': '<C-j>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<C-j>', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_jumpToRoot', 'key': 'P'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...ack': '<SNR>12_jumpToRoot', 'key': 'P'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 60:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapJumpPrevSibling, 'scope': "Node", 'callback': s."jumpToPrevSibling" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': '<C-k>', 'scope': 'Node', 'ca...'callback': '<SNR>12_jumpToPrevSibling'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': '<C-k>', 'scope': 'Node', 'ca...'callback': '<SNR>12_jumpToPrevSibling'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...R>12_jumpToPrevSibling', 'key': '<C-k>'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('<C-k>', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...>12_jumpToNextSibling', 'key': '<C-j>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...>12_jumpToNextSibling', 'key': '<C-j>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 61: [J

line 62:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Node", 'callback': s."openInNewTab" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 't', 'scope': 'Node', 'callba...de', 'callback': '<SNR>12_openInNewTab'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 't', 'scope': 'Node', 'callba...de', 'callback': '<SNR>12_openInNewTab'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ck': '<SNR>12_openInNewTab', 'key': 't'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('t', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...>12_jumpToPrevSibling', 'key': '<C-k>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...>12_jumpToPrevSibling', 'key': '<C-k>'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 63:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Node", 'callback': s."openInNewTabSilent" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'T', 'scope': 'Node', 'callba...callback': '<SNR>12_openInNewTabSilent'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'T', 'scope': 'Node', 'callba...callback': '<SNR>12_openInNewTabSilent'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_openInNewTabSilent', 'key': 'T'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('T', 'Node')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_openInNewTab', 'key': 't'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_openInNewTab', 'key': 't'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 64:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTab, 'scope': "Bookmark", 'callback': s."openInNewTab" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 't', 'scope': 'Bookmark', 'ca...rk', 'callback': '<SNR>12_openInNewTab'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 't', 'scope': 'Bookmark', 'ca...rk', 'callback': '<SNR>12_openInNewTab'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ck': '<SNR>12_openInNewTab', 'key': 't'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('t', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_openInNewTabSilent', 'key': 'T'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_openInNewTabSilent', 'key': 'T'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 65:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenInTabSilent, 'scope': "Bookmark", 'callback': s."openInNewTabSilent" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'T', 'scope': 'Bookmark', 'ca...callback': '<SNR>12_openInNewTabSilent'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'T', 'scope': 'Bookmark', 'ca...callback': '<SNR>12_openInNewTabSilent'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...<SNR>12_openInNewTabSilent', 'key': 'T'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('T', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_openInNewTab', 'key': 't'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_openInNewTab', 'key': 't'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 66: [J

line 67:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapOpenExpl, 'scope': "DirNode", 'callback': s."openExplorer" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'e', 'scope': 'DirNode', 'cal...de', 'callback': '<SNR>12_openExplorer'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'e', 'scope': 'DirNode', 'cal...de', 'callback': '<SNR>12_openExplorer'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...ck': '<SNR>12_openExplorer', 'key': 'e'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('e', 'DirNode')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_openInNewTabSilent', 'key': 'T'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...SNR>12_openInNewTabSilent', 'key': 'T'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 68: [J

line 69:     call NERDTreeAddKeyMap({ 'key': g:NERDTreeMapDeleteBookmark, 'scope': "Bookmark", 'callback': s."deleteBookmark" })[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J({'key': 'D', 'scope': 'Bookmark', 'ca...', 'callback': '<SNR>12_deleteBookmark'})

line 1:     call s:KeyMap.Create(a:options)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J({'key': 'D', 'scope': 'Bookmark', 'ca...', 'callback': '<SNR>12_deleteBookmark'})

line 1:     let newKeyMap = copy(self)[J

line 2:     let opts = extend({'scope': 'all', 'quickhelpText': ''}, copy(a:options))[J

line 3:     let newKeyMap.key = opts['key'][J

line 4:     let newKeyMap.quickhelpText = opts['quickhelpText'][J

line 5:     let newKeyMap.callback = opts['callback'][J

line 6:     let newKeyMap.scope = opts['scope'][J

line 7: [J

line 8:     call s:KeyMap.Add(newKeyMap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J({'All': function('28'), 'BindAll': fu...': '<SNR>12_deleteBookmark', 'key': 'D'})

line 1:     call s:KeyMap.Remove(a:keymap.key, a:keymap.scope)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J('D', 'Bookmark')

line 1:     let maps = s:KeyMap.All()[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_openExplorer', 'key': 'e'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

line 2:     for i in range(len(maps))[J

line 3:          if maps[i].key ==# a:key && maps[i].scope ==# a:scope[J

line 4:             return remove(maps, i)[J

line 5:         endif[J

line 6:     endfor[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..32 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

line 2:     call add(s:KeyMap.All(), a:keymap)[J

calling function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28[J()

line 1:     if !exists("s:keyMaps")[J

line 2:         let s:keyMaps = [][J

line 3:     endif[J

line 4:     return s:keyMaps[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36..28 returning [{'All': function('28'), 'BindAll': f...k': '<SNR>12_openExplorer', 'key': 'e'}][J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35..36 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap..35 returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap[J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings..NERDTreeAddKeyMap returning #0[J

continuing in function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings[J

line 70: [J

function <SNR>12_postSourceActions..<SNR>12_createDefaultBindings returning #0[J

continuing in function <SNR>12_postSourceActions[J

line 3: [J

line 4:     "load all nerdtree plugins[J

line 5:     runtime! nerdtree_plugin/**/*.vim[J

Searching for "nerdtree_plugin/**/*.vim" in "/home/vimtest/.vim/bundle/vundle,/home/vimtest/.vim/bundle/nerdtree,/home/vimtest/.vim/bundle/vim-rails,/home/vimtest/.vim,/usr/local/share/vim/vimfiles,/usr/local/share/vim/vim73,/usr/local/share/vim/vimfiles/after,/home/vimtest/.vim/after,/home/vimtest/.vim/bundle/vundle/,/home/vimtest/.vim/bundle/vim-rails/after,/home/vimtest/.vim/bundle/nerdtree/after,/home/vimtest/.vim/bundle/vundle/after"[J
Searching for "/home/vimtest/.vim/bundle/vundle/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/**/*.vim"[J
chdir(/home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim"[J
line 1: " ============================================================================[J

line 2: " File:        exec_menuitem.vim[J

line 3: " Description: plugin for NERD Tree that provides an execute file menu item[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " Last Change: 22 July, 2009[J

line 6: " License:     This program is free software. It comes without any warranty,[J

line 7: "              to the extent permitted by applicable law. You can redistribute[J

line 8: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 11: "[J

line 12: " ============================================================================[J

line 13: if exists("g:loaded_nerdtree_exec_menuitem")[J

line 14:     finish[J

line 15: endif[J

line 16: let g:loaded_nerdtree_exec_menuitem = 1[J

line 17: [J

line 22: call NERDTreeAddMenuItem({ 'text': '(!)Execute file', 'shortcut': '!', 'callback': 'NERDTreeExecFile', 'isActiveCallback': 'NERDTreeExecFileActive' })[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeExecFile', 'sho...tiveCallback': 'NERDTreeExecFileActive'})

line 1:     call s:MenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem..51[J({'callback': 'NERDTreeExecFile', 'sho...tiveCallback': 'NERDTreeExecFileActive'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem..51..49[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem..51..49 returning [][J

continuing in function NERDTreeAddMenuItem..51[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem..51 returning {'All': function('49'), 'isActiveCall...TreeExecFile', 'Create': function('51')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim[J

line 23: [J

line 24: function! NERDTreeExecFileActive()[J

line 28: [J

line 29: function! NERDTreeExecFile()[J

finished sourcing /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/exec_menuitem.vim[J
continuing in function <SNR>12_postSourceActions[J
chdir(/home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin)[J
fchdir() to previous dir[J
line 5: sourcing "/home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim"[J
line 1: " ============================================================================[J

line 2: " File:        fs_menu.vim[J

line 3: " Description: plugin for the NERD Tree that provides a file system menu[J

line 4: " Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>[J

line 5: " Last Change: 17 July, 2009[J

line 6: " License:     This program is free software. It comes without any warranty,[J

line 7: "              to the extent permitted by applicable law. You can redistribute[J

line 8: "              it and/or modify it under the terms of the Do What The Fuck You[J

line 9: "              Want To Public License, Version 2, as published by Sam Hocevar.[J

line 10: "              See http://sam.zoy.org/wtfpl/COPYING for more details.[J

line 11: "[J

line 12: " ============================================================================[J

line 13: if exists("g:loaded_nerdtree_fs_menu")[J

line 14:     finish[J

line 15: endif[J

line 16: let g:loaded_nerdtree_fs_menu = 1[J

line 17: [J

line 18: call NERDTreeAddMenuItem({'text': '(a)dd a childnode', 'shortcut': 'a', 'callback': 'NERDTreeAddNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeAddNode', 'shor...tcut': 'a', 'text': '(a)dd a childnode'})

line 1:     call s:MenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem..51[J({'callback': 'NERDTreeAddNode', 'shor...tcut': 'a', 'text': '(a)dd a childnode'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem..51..49[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem..51..49 returning [{'All': function('49'), 'isActiveCal...reeExecFile', 'Create': function('51')}][J

continuing in function NERDTreeAddMenuItem..51[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem..51 returning {'All': function('49'), 'isActiveCall...DTreeAddNode', 'Create': function('51')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 19: call NERDTreeAddMenuItem({'text': '(m)ove the current node', 'shortcut': 'm', 'callback': 'NERDTreeMoveNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeMoveNode', 'sho... 'm', 'text': '(m)ove the current node'})

line 1:     call s:MenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem..51[J({'callback': 'NERDTreeMoveNode', 'sho... 'm', 'text': '(m)ove the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem..51..49[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem..51..49 returning [{'All': function('49'), 'isActiveCal...TreeAddNode', 'Create': function('51')}][J

continuing in function NERDTreeAddMenuItem..51[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem..51 returning {'All': function('49'), 'isActiveCall...TreeMoveNode', 'Create': function('51')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 20: call NERDTreeAddMenuItem({'text': '(d)elete the current node', 'shortcut': 'd', 'callback': 'NERDTreeDeleteNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeDeleteNode', 's...d', 'text': '(d)elete the current node'})

line 1:     call s:MenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem..51[J({'callback': 'NERDTreeDeleteNode', 's...d', 'text': '(d)elete the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem..51..49[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem..51..49 returning [{'All': function('49'), 'isActiveCal...reeMoveNode', 'Create': function('51')}][J

continuing in function NERDTreeAddMenuItem..51[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem..51 returning {'All': function('49'), 'isActiveCall...eeDeleteNode', 'Create': function('51')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 21: [J

line 22: if has("gui_mac") || has("gui_macvim") [J

line 23:     call NERDTreeAddMenuItem({'text': '(r)eveal in Finder the current node', 'shortcut': 'r', 'callback': 'NERDTreeRevealInFinder'})[J

line 24:     call NERDTreeAddMenuItem({'text': '(o)pen the current node with system editor', 'shortcut': 'o', 'callback': 'NERDTreeExecuteFile'})[J

line 25:     call NERDTreeAddMenuItem({'text': '(q)uicklook the current node', 'shortcut': 'q', 'callback': 'NERDTreeQuickLook'})[J

line 26: endif[J

line 27: [J

line 28: if g:NERDTreePath.CopyingSupported()[J

calling function 134[J()

line 1:     return exists('g:NERDTreeCopyCmd')[J

function 134 returning #1[J

continuing in /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 29:     call NERDTreeAddMenuItem({'text': '(c)copy the current node', 'shortcut': 'c', 'callback': 'NERDTreeCopyNode'})[J

calling function NERDTreeAddMenuItem[J({'callback': 'NERDTreeCopyNode', 'sho...'c', 'text': '(c)copy the current node'})

line 1:     call s:MenuItem.Create(a:options)[J

calling function NERDTreeAddMenuItem..51[J({'callback': 'NERDTreeCopyNode', 'sho...'c', 'text': '(c)copy the current node'})

line 1:     let newMenuItem = copy(self)[J

line 2: [J

line 3:     let newMenuItem.text = a:options['text'][J

line 4:     let newMenuItem.shortcut = a:options['shortcut'][J

line 5:     let newMenuItem.children = [][J

line 6: [J

line 7:     let newMenuItem.isActiveCallback = -1[J

line 8:     if has_key(a:options, 'isActiveCallback')[J

line 9:         let newMenuItem.isActiveCallback = a:options['isActiveCallback'][J

line 10:     endif[J

line 11: [J

line 12:     let newMenuItem.callback = -1[J

line 13:     if has_key(a:options, 'callback')[J

line 14:         let newMenuItem.callback = a:options['callback'][J

line 15:     endif[J

line 16: [J

line 17:     if has_key(a:options, 'parent')[J

line 18:         call add(a:options['parent'].children, newMenuItem)[J

line 19:     else[J

line 20:         call add(s:MenuItem.All(), newMenuItem)[J

calling function NERDTreeAddMenuItem..51..49[J()

line 1:     if !exists("s:menuItems")[J

line 2:         let s:menuItems = [][J

line 3:     endif[J

line 4:     return s:menuItems[J

function NERDTreeAddMenuItem..51..49 returning [{'All': function('49'), 'isActiveCal...eDeleteNode', 'Create': function('51')}][J

continuing in function NERDTreeAddMenuItem..51[J

line 21:     endif[J

line 22: [J

line 23:     return newMenuItem[J

function NERDTreeAddMenuItem..51 returning {'All': function('49'), 'isActiveCall...TreeCopyNode', 'Create': function('51')}[J

continuing in function NERDTreeAddMenuItem[J

function NERDTreeAddMenuItem returning #0[J

continuing in /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J

line 30: endif[J

line 31: [J

line 32: "FUNCTION: s:echo(msg){{{1[J

line 33: function! s:echo(msg)[J

line 37: [J

line 38: "FUNCTION: s:echoWarning(msg){{{1[J

line 39: function! s:echoWarning(msg)[J

line 44: [J

line 45: "FUNCTION: s:promptToDelBuffer(bufnum, msg){{{1[J

line 46: "prints out the given msg and, if the user responds by pushing 'y' then the[J

line 47: "buffer with the given bufnum is deleted[J

line 48: "[J

line 49: "Args:[J

line 50: "bufnum: the buffer that may be deleted[J

line 51: "msg: a message that will be echoed to the user asking them if they wish to[J

line 52: "     del the buffer[J

line 53: function! s:promptToDelBuffer(bufnum, msg)[J

line 59: [J

line 60: "FUNCTION: NERDTreeAddNode(){{{1[J

line 61: function! NERDTreeAddNode()[J

line 88: [J

line 89: "FUNCTION: NERDTreeMoveNode(){{{1[J

line 90: function! NERDTreeMoveNode()[J

line 122: [J

line 123: " FUNCTION: NERDTreeDeleteNode() {{{1[J

line 124: function! NERDTreeDeleteNode()[J

line 166: [J

line 167: " FUNCTION: NERDTreeCopyNode() {{{1[J

line 168: function! NERDTreeCopyNode()[J

line 202: [J

line 203: function! NERDTreeQuickLook()[J

line 209: [J

line 210: function! NERDTreeRevealInFinder()[J

line 216: [J

line 217: function! NERDTreeExecuteFile()[J

line 223: [J

line 224: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/vimtest/.vim/bundle/nerdtree/nerdtree_plugin/fs_menu.vim[J
continuing in function <SNR>12_postSourceActions[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vim73/nerdtree_plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/after/nerdtree_plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/after/nerdtree_plugin/**/*.vim"[J
function <SNR>12_postSourceActions returning #0[J

continuing in /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J

line 4364: [J

line 4365: "reset &cpo back to users setting[J

line 4366: let &cpo = s:old_cpo[J

line 4367: [J

line 4368: " vim: set sw=4 sts=4 et fdm=marker:[J

finished sourcing /home/vimtest/.vim/bundle/nerdtree/plugin/NERD_tree.vim[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/plugin/**/*.vim"[J
chdir(/home/vimtest/.vim/bundle/vim-rails/plugin)[J
fchdir() to previous dir[J
sourcing "/home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim"[J
line 1: " rails.vim - Detect a rails application[J

line 2: " Author:       Tim Pope <http://tpo.pe/>[J

line 3: " GetLatestVimScripts: 1567 1 :AutoInstall: rails.vim[J

line 4: [J

line 5: " Install this file as plugin/rails.vim.  See doc/rails.txt for details. (Grab[J

line 6: " it from the URL above if you don't have it.)  To access it from Vim, see[J

line 7: " :help add-local-help (hint: :helptags ~/.vim/doc) Afterwards, you should be[J

line 8: " able to do :help rails[J

line 9: [J

line 10: if exists('g:loaded_rails') || &cp || v:version < 700[J

line 11:   finish[J

line 12: endif[J

line 13: let g:loaded_rails = 1[J

line 14: [J

line 15: " Utility Functions {{{1[J

line 16: [J

line 17: function! s:error(str)[J

line 23: [J

line 24: function! s:autoload(...)[J

line 44: [J

line 45: " }}}1[J

line 46: " Configuration {{{[J

line 47: [J

line 48: function! s:SetOptDefault(opt,val)[J

line 53: [J

line 54: call s:SetOptDefault("rails_statusline",1)[J

calling function <SNR>15_SetOptDefault[J('rails_statusline', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 55: call s:SetOptDefault("rails_syntax",1)[J

calling function <SNR>15_SetOptDefault[J('rails_syntax', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 56: call s:SetOptDefault("rails_mappings",1)[J

calling function <SNR>15_SetOptDefault[J('rails_mappings', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 57: call s:SetOptDefault("rails_abbreviations",1)[J

calling function <SNR>15_SetOptDefault[J('rails_abbreviations', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 58: call s:SetOptDefault("rails_ctags_arguments","--languages=-javascript")[J

calling function <SNR>15_SetOptDefault[J('rails_ctags_arguments', '--languages=-javascript')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 59: call s:SetOptDefault("rails_default_file","README")[J

calling function <SNR>15_SetOptDefault[J('rails_default_file', 'README')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 60: call s:SetOptDefault("rails_root_url",'http://localhost:3000/')[J

calling function <SNR>15_SetOptDefault[J('rails_root_url', 'http://localhost:3000/')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 61: call s:SetOptDefault("rails_modelines",0)[J

calling function <SNR>15_SetOptDefault[J('rails_modelines', 0)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 62: call s:SetOptDefault("rails_gnu_screen",1)[J

calling function <SNR>15_SetOptDefault[J('rails_gnu_screen', 1)

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 63: call s:SetOptDefault("rails_generators","controller\ngenerator\nhelper\nintegration_test\nmailer\nmetal\nmigration\nmodel\nobserver\nperformance_test\nplugin\nresource\nscaffold\nscaffold_controller\nsession_migration\nstylesheets")[J

calling function <SNR>15_SetOptDefault[J('rails_generators', 'controller
generator
helper
integ...troller
session_migration
stylesheets')

line 1:   if !exists("g:".a:opt)[J

line 2:     let g:{a:opt} = a:val[J

line 3:   endif[J

function <SNR>15_SetOptDefault returning #0[J

continuing in /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J

line 64: if exists("g:loaded_dbext") && executable("sqlite3") && ! executable("sqlite")[J

line 65:   " Since dbext can't find it by itself[J

line 66:   call s:SetOptDefault("dbext_default_SQLITE_bin","sqlite3")[J

line 67: endif[J

line 68: [J

line 69: " }}}1[J

line 70: " Detection {{{1[J

line 71: [J

line 72: function! s:escvar(r)[J

line 78: [J

line 79: function! s:Detect(filename)[J

line 115: [J

line 116: function! s:BufInit(path)[J

line 122: [J

line 123: " }}}1[J

line 124: " Initialization {{{1[J

line 125: [J

line 126: augroup railsPluginDetect[J

line 127:   autocmd![J

line 128:   autocmd BufNewFile,BufRead * call s:Detect(expand("<afile>:p"))[J

line 129:   autocmd VimEnter * if expand("<amatch>") == "" && !exists("b:rails_root") | call s:Detect(getcwd()) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif[J

line 130:   autocmd FileType netrw if !exists("b:rails_root") | call s:Detect(expand("%:p")) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif[J

line 131:   autocmd BufEnter * if exists("b:rails_root")|silent doau User BufEnterRails|endif[J

line 132:   autocmd BufLeave * if exists("b:rails_root")|silent doau User BufLeaveRails|endif[J

line 133:   autocmd Syntax railslog if s:autoload()|call rails#log_syntax()|endif[J

line 134: augroup END[J

line 135: [J

line 136: command! -bar -bang -nargs=* -complete=dir Rails :if s:autoload()|call rails#new_app_command(<bang>0,<f-args>)|endif[J

line 137: [J

line 138: " }}}1[J

line 139: " abolish.vim support {{{1[J

line 140: [J

line 141: function! s:function(name)[J

line 144: [J

line 145: augroup railsPluginAbolish[J

line 146:   autocmd![J

line 147:   autocmd VimEnter * call s:abolish_setup()[J

line 148: augroup END[J

line 149: [J

line 150: function! s:abolish_setup()[J

line 160: [J

line 161: function! s:abolish_l(word)[J

line 165: [J

line 166: function! s:abolish_t(word)[J

line 173: [J

line 174: " }}}1[J

line 175: " vim:set sw=2 sts=2:[J

finished sourcing /home/vimtest/.vim/bundle/vim-rails/plugin/rails.vim[J
Searching for "/home/vimtest/.vim/plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vimfiles/plugin/**/*.vim"[J
Searching for "/usr/local/share/vim/vim73/plugin/**/*.vim"[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/getscriptPlugin.vim"[J
line 1: " ---------------------------------------------------------------------[J

line 2: " getscriptPlugin.vim[J

line 3: "  Author:^ICharles E. Campbell, Jr.[J

line 4: "  Date:^IJan 07, 2008[J

line 5: "  Installing:^I:help glvs-install[J

line 6: "  Usage:^I:help glvs[J

line 7: "[J

line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim[J

line 9: "[J

line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let[J

line 11: " all the peoples praise Him."[J

line 12: " ---------------------------------------------------------------------[J

line 13: " Initialization:^I{{{1[J

line 14: " if you're sourcing this file, surely you can't be[J

line 15: " expecting vim to be in its vi-compatible mode[J

line 16: if &cp || exists("g:loaded_getscriptPlugin")[J

line 17:  if &verbose[J

line 18:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"[J

line 19:  endif[J

line 20:  finish[J

line 21: endif[J

line 22: let g:loaded_getscriptPlugin = "v32"[J

line 23: let s:keepcpo                = &cpo[J

line 24: set cpo&vim[J

line 25: [J

line 26: " ---------------------------------------------------------------------[J

line 27: "  Public Interface: {{{1[J

line 28: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()[J

line 29: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()[J

line 30: silent! com -nargs=0 GLVS                call getscript#GetLatestVimScripts()[J

line 31: [J

line 32: " ---------------------------------------------------------------------[J

line 33: " Restore Options: {{{1[J

line 34: let &cpo= s:keepcpo[J

line 35: unlet s:keepcpo[J

line 36: [J

line 37: " ---------------------------------------------------------------------[J

line 38: " vim: ts=8 sts=2 fdm=marker nowrap[J

finished sourcing /usr/local/share/vim/vim73/plugin/getscriptPlugin.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/gzip.vim"[J
line 1: " Vim plugin for editing compressed files.[J

line 2: " Maintainer: Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2010 Mar 10[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of compressed files[J

line 9: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_gzip = 1[J

line 13: [J

line 14: augroup gzip[J

line 15:   " Remove all gzip autocommands[J

line 16:   au![J

line 17: [J

line 18:   " Enable editing of gzipped files.[J

line 19:   " The functions are defined in autoload/gzip.vim.[J

line 20:   "[J

line 21:   " Set binary mode before reading the file.[J

line 22:   " Use "gzip -d", gunzip isn't always available.[J

line 23:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz setlocal bin[J

line 24:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")[J

line 25:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")[J

line 26:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")[J

line 27:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")[J

line 28:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")[J

line 29:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")[J

line 30:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")[J

line 31:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")[J

line 32:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")[J

line 33:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")[J

line 34:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")[J

line 35:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")[J

line 36:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")[J

line 37:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")[J

line 38:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")[J

line 39:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")[J

line 40:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")[J

line 41:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")[J

line 42:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")[J

line 43:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")[J

line 44: augroup END[J

finished sourcing /usr/local/share/vim/vim73/plugin/gzip.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/matchparen.vim"[J
line 1: " Vim plugin for showing matching parens[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2008 Sep 03[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded (or disabled)[J

line 7: " - when 'compatible' is set[J

line 8: " - the "CursorMoved" autocmd event is not availble.[J

line 9: if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")[J

line 10:   finish[J

line 11: endif[J

line 12: let g:loaded_matchparen = 1[J

line 13: [J

line 14: augroup matchparen[J

line 15:   " Replace all matchparen autocommands[J

line 16:   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()[J

line 17: augroup END[J

line 18: [J

line 19: " Skip the rest if it was already done.[J

line 20: if exists("*s:Highlight_Matching_Pair")[J

line 21:   finish[J

line 22: endif[J

line 23: [J

line 24: let s:cpo_save = &cpo[J

line 25: set cpo-=C[J

line 26: [J

line 27: " The function that is invoked (very often) to define a ":match" highlighting[J

line 28: " for any matching paren.[J

line 29: function! s:Highlight_Matching_Pair()[J

line 144: [J

line 145: " Define commands that will disable and enable the plugin.[J

line 147: command! NoMatchParen windo 3match none | unlet! g:loaded_matchparen | au! matchparen[J

line 148: command! DoMatchParen runtime plugin/matchparen.vim | windo doau CursorMoved[J

line 149: [J

line 150: let &cpo = s:cpo_save[J

line 151: unlet s:cpo_save[J

finished sourcing /usr/local/share/vim/vim73/plugin/matchparen.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/netrwPlugin.vim"[J
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network[J

line 2: "            PLUGIN SECTION[J

line 3: " Date:^I^IJul 27, 2010[J

line 4: " Maintainer:^ICharles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim[J

line 6: " Copyright:    Copyright (C) 1999-2008 Charles E. Campbell, Jr. {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided[J

line 11: "               *as is* and comes with no warranty of any kind, either[J

line 12: "               expressed or implied. By using this plugin, you agree that[J

line 13: "               in no event will the copyright holder be liable for any damages[J

line 14: "               resulting from the use of this software.[J

line 15: "[J

line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1[J

line 17: "  (James 1:22 RSV)[J

line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_netrwPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_netrwPlugin = "v140"[J

line 24: if v:version < 702[J

line 25:  echohl WarningMsg | echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None[J

line 25:  echo "***netrw*** you need vim version 7.2 for this version of netrw" | echohl None[J

line 25:  echohl None[J

line 26:  finish[J

line 27: endif[J

line 28: let s:keepcpo = &cpo[J

line 29: set cpo&vim[J

line 30: [J

line 31: " ---------------------------------------------------------------------[J

line 32: " Public Interface: {{{1[J

line 33: [J

line 34: " Local Browsing: {{{2[J

line 35: augroup FileExplorer[J

line 36:  au![J

line 37:  au BufEnter * silent! call s:LocalBrowse(expand("<amatch>"))[J

line 38:  au VimEnter * silent! call s:VimEnter(expand("<amatch>"))[J

line 39:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 40:   au BufEnter .* silent! call s:LocalBrowse(expand("<amatch>"))[J

line 41:  endif[J

line 42: augroup END[J

line 43: [J

line 44: " Network Browsing Reading Writing: {{{2[J

line 45: augroup Network[J

line 46:  au![J

line 47:  if has("win32") || has("win95") || has("win64") || has("win16")[J

line 48:   au BufReadCmd  file://*^I^Iexe "silent doau BufReadPre ".fnameescape(netrw#RFC2396(expand("<amatch>")))|exe 'e '.fnameescape(substitute(netrw#RFC2396(expand("<amatch>")),'file://\(.*\)','\1',""))|exe "bwipe ".fnameescape(expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(netrw#RFC2396(expand("<amatch>")))[J

line 49:  else[J

line 50:   au BufReadCmd  file://*^I^Iexe "silent doau BufReadPre ".fnameescape(netrw#RFC2396(expand("<amatch>")))|exe 'e '.fnameescape(substitute(netrw#RFC2396(expand("<amatch>")),'file://\(.*\)','\1',""))|exe "bwipe ".fnameescape(expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(netrw#RFC2396(expand("<amatch>")))[J

line 51:   au BufReadCmd  file://localhost/*^Iexe "silent doau BufReadPre ".fnameescape(netrw#RFC2396(expand("<amatch>")))|exe 'e '.fnameescape(substitute(netrw#RFC2396(expand("<amatch>")),'file://localhost/\(.*\)','\1',""))|exe "bwipe ".fnameescape(substitute(expand("<amatch>"),'file://\(\k\+@\)\=','',''))|exe "silent doau BufReadPost ".fnameescape(netrw#RFC2396(expand("<amatch>")))[J

line 52:  endif[J

line 53:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "silent doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "silent doau BufReadPost ".fnameescape(expand("<amatch>"))[J

line 54:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "silent doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "silent doau FileReadPost ".fnameescape(expand("<amatch>"))[J

line 55:  au BufWriteCmd  ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*^I^Iexe "silent doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "silent doau BufWritePost ".fnameescape(expand("<amatch>"))[J

line 56:  au FileWriteCmd ftp://*,rcp://*,scp://*,dav://*,davs://*,rsync://*,sftp://*^I^Iexe "silent doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "silent doau FileWritePost ".fnameescape(expand("<amatch>"))[J

line 57:  try[J

line 58:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 59:  catch /^Vim\%((\a\+)\)\=:E216/[J

line 60:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))[J

line 61:  endtry[J

line 62: augroup END[J

line 63: [J

line 64: " Commands: :Nread, :Nwrite, :NetUserPass {{{2[J

line 65: com! -count=1 -nargs=*^INread^I^Icall netrw#NetrwSavePosn()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call netrw#NetrwRestorePosn()[J

line 66: com! -range=% -nargs=*^INwrite^I^Icall netrw#NetrwSavePosn()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call netrw#NetrwRestorePosn()[J

line 67: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)[J

line 68: com! -nargs=*^I        Nsource^I^Icall netrw#NetrwSavePosn()<bar>call netrw#NetSource(<f-args>)<bar>call netrw#NetrwRestorePosn()[J

line 69: [J

line 70: " Commands: :Explore, :Sexplore, Hexplore, Vexplore {{{2[J

line 71: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)[J

line 72: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)[J

line 73: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)[J

line 74: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)[J

line 75: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)[J

line 76: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)[J

line 77: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)[J

line 78: [J

line 79: " Commands: NetrwSettings {{{2[J

line 80: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()[J

line 81: com! -bang^INetrwClean^Icall netrw#NetrwClean(<bang>0)[J

line 82: [J

line 83: " Maps:[J

line 84: if !exists("g:netrw_nogx") && maparg('gx','n') == ""[J

line 85:  if !hasmapto('<Plug>NetrwBrowseX')[J

line 86:   nmap <unique> gx <Plug>NetrwBrowseX[J

line 87:  endif[J

line 88:  nno <silent> <Plug>NetrwBrowseX :call netrw#NetrwBrowseX(expand("<cWORD>"),0)<cr>[J

line 89: endif[J

line 90: [J

line 91: " ---------------------------------------------------------------------[J

line 92: " LocalBrowse: {{{2[J

line 93: fun! s:LocalBrowse(dirname)[J

line 111: [J

line 112: " ---------------------------------------------------------------------[J

line 113: " s:VimEnter: {{{2[J

line 114: fun! s:VimEnter(dirname)[J

line 119: [J

line 120: " ---------------------------------------------------------------------[J

line 121: " NetrwStatusLine: {{{1[J

line 122: fun! NetrwStatusLine()[J

line 133: [J

line 134: " ------------------------------------------------------------------------[J

line 135: " NetUserPass: set username and password for subsequent ftp transfer {{{1[J

line 136: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password[J

line 137: "^I    :call NetUserPass("uid")^I^I-- will prompt for password[J

line 138: "^I    :call NetUserPass("uid","password") -- sets global userid and password[J

line 139: fun! NetUserPass(...)[J

line 163: [J

line 164: " ------------------------------------------------------------------------[J

line 165: " Modelines And Restoration: {{{1[J

line 166: let &cpo= s:keepcpo[J

line 167: unlet s:keepcpo[J

line 168: " vim:ts=8 fdm=marker[J

finished sourcing /usr/local/share/vim/vim73/plugin/netrwPlugin.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/rrhelper.vim"[J
line 1: " Vim plugin with helper function(s) for --remote-wait[J

line 2: " Maintainer: Flemming Madsen <fma@cci.dk>[J

line 3: " Last Change: 2008 May 29[J

line 4: [J

line 5: " Has this already been loaded?[J

line 6: if exists("loaded_rrhelper") || !has("clientserver")[J

line 7:   finish[J

line 8: endif[J

line 9: let loaded_rrhelper = 1[J

line 10: [J

line 11: " Setup answers for a --remote-wait client who will assume[J

line 12: " a SetupRemoteReplies() function in the command server[J

line 13: [J

line 14: function SetupRemoteReplies()[J

line 41: [J

line 42: function DoRemoteReply(id, cnt, group, file)[J

line 47: [J

line 48: " vim: set sw=2 sts=2 :[J

finished sourcing /usr/local/share/vim/vim73/plugin/rrhelper.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/spellfile.vim"[J
line 1: " Vim plugin for downloading spell files[J

line 2: " Maintainer:  Bram Moolenaar <Bram@vim.org>[J

line 3: " Last Change: 2006 Feb 01[J

line 4: [J

line 5: " Exit quickly when:[J

line 6: " - this plugin was already loaded[J

line 7: " - when 'compatible' is set[J

line 8: " - some autocommands are already taking care of spell files[J

line 9: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")[J

line 10:   finish[J

line 11: endif[J

line 12: let loaded_spellfile_plugin = 1[J

line 13: [J

line 14: " The function is in the autoload directory.[J

line 15: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))[J

finished sourcing /usr/local/share/vim/vim73/plugin/spellfile.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/tarPlugin.vim"[J
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles[J

line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>[J

line 3: " Modified by Charles E. Campbell, Jr.[J

line 4: " Distributed under the GNU General Public License.[J

line 5: "[J

line 6: " Updates are available from <http://michael.toren.net/code/>.  If you[J

line 7: " find this script useful, or have suggestions for improvements, please[J

line 8: " let me know.[J

line 9: " Also look there for further comments and documentation.[J

line 10: "[J

line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.[J

line 12: " ---------------------------------------------------------------------[J

line 13: "  Load Once: {{{1[J

line 14: if &cp || exists("g:loaded_tarPlugin")[J

line 15:  finish[J

line 16: endif[J

line 17: let g:loaded_tarPlugin = "v26"[J

line 18: let s:keepcpo          = &cpo[J

line 19: set cpo&vim[J

line 20: [J

line 21: " ---------------------------------------------------------------------[J

line 22: "  Public Interface: {{{1[J

line 23: augroup tar[J

line 24:   au![J

line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)[J

line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)[J

line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))[J

line 29: [J

line 30:   if has("unix")[J

line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)[J

line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)[J

line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))[J

line 35:   endif[J

line 36: [J

line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))[J

line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))[J

line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))[J

line 42:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 43:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))[J

line 44:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))[J

line 45:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))[J

line 46: augroup END[J

line 47: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)[J

line 48: [J

line 49: " ---------------------------------------------------------------------[J

line 50: " Restoration And Modelines: {{{1[J

line 51: " vim: fdm=marker[J

line 52: let &cpo= s:keepcpo[J

line 53: unlet s:keepcpo[J

finished sourcing /usr/local/share/vim/vim73/plugin/tarPlugin.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/tohtml.vim"[J
line 1: " Vim plugin for converting a syntax highlighted file to HTML.[J

line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>[J

line 3: " Last Change: 2010 Aug 12[J

line 4: "[J

line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and[J

line 6: " $VIMRUNTIME/syntax/2html.vim[J

line 7: "[J

line 8: " TODO:[J

line 9: "   * Restore open/closed folds and cursor position after processing each file[J

line 10: "     with option not to restore for speed increase[J

line 11: "   * Add extra meta info (generation time, etc.)[J

line 12: "   * Tidy up so we can use strict doctype more?[J

line 13: "   * Implementation detail: add threshold for writing the lines to the html[J

line 14: "     buffer before we're done (5000 or so lines should do it)[J

line 15: "   * TODO comments for code cleanup scattered throughout[J

line 16: [J

line 17: if exists('g:loaded_2html_plugin')[J

line 18:   finish[J

line 19: endif[J

line 20: let g:loaded_2html_plugin = 'vim7.3_v6'[J

line 21: [J

line 22: " Define the :TOhtml command when:[J

line 23: " - 'compatible' is not set[J

line 24: " - this plugin was not already loaded[J

line 25: " - user commands are available.[J

line 26: if !&cp && !exists(":TOhtml") && has("user_commands")[J

line 27:   command -range=% TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)[J

line 28: endif[J

line 29: [J

line 30: " Make sure any patches will probably use consistent indent[J

line 31: "   vim: ts=8 sw=2 sts=2 noet[J

finished sourcing /usr/local/share/vim/vim73/plugin/tohtml.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/vimballPlugin.vim"[J
line 1: " vimballPlugin : construct a file containing both paths and files[J

line 2: " Author: Charles E. Campbell, Jr.[J

line 3: " Copyright: (c) 2004-2010 by Charles E. Campbell, Jr.[J

line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt[J

line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".[J

line 6: "            No warranty, express or implied.[J

line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***[J

line 8: "[J

line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who[J

line 10: "      judge. For in that which you judge another, you condemn yourself. For[J

line 11: "      you who judge practice the same things.[J

line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim[J

line 13: [J

line 14: " ---------------------------------------------------------------------[J

line 15: "  Load Once: {{{1[J

line 16: if &cp || exists("g:loaded_vimballPlugin")[J

line 17:  finish[J

line 18: endif[J

line 19: let g:loaded_vimballPlugin = "v31"[J

line 20: let s:keepcpo              = &cpo[J

line 21: set cpo&vim[J

line 22: [J

line 23: " ------------------------------------------------------------------------------[J

line 24: " Public Interface: {{{1[J

line 25: com! -ra   -complete=file -na=+ -bang MkVimball call vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)[J

line 26: com! -na=? -complete=dir  UseVimball^I^I^Icall vimball#Vimball(1,<f-args>)[J

line 27: com! -na=0                VimballList^I^I^Icall vimball#Vimball(0)[J

line 28: com! -na=* -complete=dir  RmVimball^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()[J

line 29: au SourceCmd  *.vba.gz,*.vba.bz2,*.vba.zip^I^Icall vimball#Decompress(expand("<amatch>"))|call vimball#Vimball(1)[J

line 30: au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip^Isetlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'| setlocal ma ff=unix noma |endif|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")[J

line 31: [J

line 32: " =====================================================================[J

line 33: " Restoration And Modelines: {{{1[J

line 34: " vim: fdm=marker[J

line 35: let &cpo= s:keepcpo[J

line 36: unlet s:keepcpo[J

finished sourcing /usr/local/share/vim/vim73/plugin/vimballPlugin.vim[J
chdir(/usr/local/share/vim/vim73/plugin)[J
fchdir() to previous dir[J
sourcing "/usr/local/share/vim/vim73/plugin/zipPlugin.vim"[J
line 1: " zipPlugin.vim: Handles browsing zipfiles[J

line 2: "            PLUGIN PORTION[J

line 3: " Date:^I^I^IOct 05, 2007[J

line 4: " Maintainer:^ICharles E Campbell, Jr <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>[J

line 5: " License:^I^IVim License  (see vim's :help license)[J

line 6: " Copyright:    Copyright (C) 2005,2006 Charles E. Campbell, Jr. {{{1[J

line 7: "               Permission is hereby granted to use and distribute this code,[J

line 8: "               with or without modifications, provided that this copyright[J

line 9: "               notice is copied with it. Like anything else that's free,[J

line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty[J

line 11: "               of any kind, either expressed or implied. By using this[J

line 12: "               plugin, you agree that in no event will the copyright[J

line 13: "               holder be liable for any damages resulting from the use[J

line 14: "               of this software.[J

line 15: "[J

line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.[J

line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.[J

line 18: " ---------------------------------------------------------------------[J

line 19: " Load Once: {{{1[J

line 20: if &cp || exists("g:loaded_zipPlugin")[J

line 21:  finish[J

line 22: endif[J

line 23: let g:loaded_zipPlugin = "v23"[J

line 24: let s:keepcpo          = &cpo[J

line 25: set cpo&vim[J

line 26: [J

line 27: " ---------------------------------------------------------------------[J

line 28: " Public Interface: {{{1[J

line 29: augroup zip[J

line 30:  au![J

line 31:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)[J

line 32:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)[J

line 33:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 34:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))[J

line 35: [J

line 36:  if has("unix")[J

line 37:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)[J

line 38:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)[J

line 39:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 40:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))[J

line 41:  endif[J

line 42: [J

line 43:  au BufReadCmd   *.zip,*.jar,*.xpi,*.war,*.ear^I^Icall zip#Browse(expand("<amatch>"))[J

line 44: augroup END[J

line 45: [J

line 46: " ---------------------------------------------------------------------[J

line 47: "  Restoration And Modelines: {{{1[J

line 48: "  vim: fdm=marker[J

line 49: let &cpo= s:keepcpo[J

line 50: unlet s:keepcpo[J

finished sourcing /usr/local/share/vim/vim73/plugin/zipPlugin.vim[J
Searching for "/usr/local/share/vim/vimfiles/after/plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/after/plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/vim-rails/after/plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/nerdtree/after/plugin/**/*.vim"[J
Searching for "/home/vimtest/.vim/bundle/vundle/after/plugin/**/*.vim"[JNo protocol specified
No protocol specified

Reading viminfo file "/home/vimtest/.viminfo" info oldfiles[JNo protocol specified
Opening the X display failed[J[?1000h
Press ENTER or type command to continue[?1000l[?12l[?25h[?1000h[?1049h[?1h=[1;70r[?12;25h[?12l[?25h[27m[m[H[2J[?25l[70;1HExecuting BufEnter Auto commands for "*"
autocommand call s:checkForBrowse(expand("<amatch>"))
line 0: call s:checkForBrowse(expand("<amatch>"))
calling function <SNR>12_checkForBrowse('')
line 1:     if a:dir != '' && isdirectory(a:dir)
line 2:[9Ccall s:initNerdTreeInPlace(a:dir)
line 3:     endif
function <SNR>12_checkForBrowse returning #0
continuing in BufEnter Auto commands for "*"
Executing BufEnter Auto commands for "*"
autocommand if exists("b:rails_root")|silent doau User BufEnterRails|endif
line 0: if exists("b:rails_root")|silent doau User BufEnterRails|endif
line 0: silent doau User BufEnterRails|endif
line 0: endif
Executing BufEnter Auto commands for "*"
autocommand silent! call s:LocalBrowse(expand("<amatch>"))
line 0: silent! call s:LocalBrowse(expand("<amatch>"))
Executing VimEnter Auto commands for "*"[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lautocommand silent! autocmd! FileExplorer[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lline 0: silent! autocmd! FileExplorer
autocommand call s:checkForBrowse(expand("<amatch>"))[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lline 0: call s:checkForBrowse(expand("<amatch>"))
calling function <SNR>12_checkForBrowse('')
line 1:     if a:dir != '' && isdirectory(a:dir)
line 2:[9Ccall s:initNerdTreeInPlace(a:dir)
line 3:     endif
function <SNR>12_checkForBrowse returning #0
continuing in VimEnter Auto commands for "*"
Executing VimEnter Auto commands for "*"[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lautocommand if expand("<amatch>") == "" && !exists("b:rails_root") | call s:Detect(getcwd()) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lline 0: if expand("<amatch>") == "" && !exists("b:rails_root") | call s:Detect(getcwd()) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif
line 0:  call s:Detect(getcwd()) | endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif
calling function <SNR>15_Detect('/home/vimtest/.vim')
line 1:   if exists('b:rails_root')
line 2:     return s:BufInit(b:rails_root)
line 3:   endif
line 4:   let fn = substitute(fnamemodify(a:filename,":p"),'\c^file://','','')
line 5:   let sep = matchstr(fn,'^[^\\/]\{3,\}\zs[\\/]')
line 6:   if sep != ""
line 7:     let fn = getcwd().sep.fn
line 8:   endif
line 9:   if fn =~ '[\/]config[\/]environment\.rb$'
line 10:     return s:BufInit(strpart(fn,0,strlen(fn)-22))
line 11:   endif
line 12:   if isdirectory(fn)
line 13:     let fn = fnamemodify(fn,':s?[\/]$??')
line 14:   else
line 15:     let fn = fnamemodify(fn,':s?\(.*\)[\/][^\/]*$?\1?')
line 16:   endif
line 17:   let ofn = ""
line 18:   let nfn = fn
line 19:   while nfn != ofn && nfn != ""
line 20:     if exists("s:_".s:escvar(nfn))
calling function <SNR>15_Detect..<SNR>15_escvar('/home/vimtest/.vim')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>15_Detect..<SNR>15_escvar returning '_126__47__46_vim'
continuing in function <SNR>15_Detect
line 21:[7Creturn s:BufInit(nfn)
line 22:     endif
line 23:     let ofn = nfn
line 24:     let nfn = fnamemodify(nfn,':h')
line 25:   endwhile
line 19:   while nfn != ofn && nfn != ""
line 20:     if exists("s:_".s:escvar(nfn))
calling function <SNR>15_Detect..<SNR>15_escvar('/home/vimtest')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>15_Detect..<SNR>15_escvar returning '_126__47_'
continuing in function <SNR>15_Detect
line 21:[7Creturn s:BufInit(nfn)
line 22:     endif
line 23:     let ofn = nfn
line 24:     let nfn = fnamemodify(nfn,':h')
line 25:   endwhile
line 19:   while nfn != ofn && nfn != ""
line 20:     if exists("s:_".s:escvar(nfn))
calling function <SNR>15_Detect..<SNR>15_escvar('/home')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
line 4:   return r
function <SNR>15_Detect..<SNR>15_escvar returning '_47_home'
continuing in function <SNR>15_Detect
line 21:[7Creturn s:BufInit(nfn)
line 22:     endif
line 23:     let ofn = nfn
line 24:     let nfn = fnamemodify(nfn,':h')
line 25:   endwhile
line 19:   while nfn != ofn && nfn != ""
line 20:     if exists("s:_".s:escvar(nfn))
calling function <SNR>15_Detect..<SNR>15_escvar('/')
line 1:   let r = fnamemodify(a:r,':~')
line 2:   let r = substitute(r,'\W','\="_".char2nr(submatch(0))."_"','g')
line 3:   let r = substitute(r,'^\d','_&','')
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hline 4:   return r
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hfunction <SNR>15_Detect..<SNR>15_escvar returning '_47_'
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hcontinuing in function <SNR>15_Detect
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hline 21:[7Creturn s:BufInit(nfn)
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hline 22:     endif
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hline 23:     let ofn = nfn
[?1000l-- More --[?12l[?25h[70;1H[K[?1000h[?25l[70;1Hline 24:     let nfn = fnamemodify(nfn,':h')
line 25:   endwhile
line 19:   while nfn != ofn && nfn != ""
line 20:     if exists("s:_".s:escvar(nfn))
line 21:[7Creturn s:BufInit(nfn)
line 22:     endif
line 23:     let ofn = nfn
line 24:     let nfn = fnamemodify(nfn,':h')
line 25:   endwhile
line 26:   let ofn = ""
line 27:   while fn != ofn
line 28:     if filereadable(fn . "/config/environment.rb")
line 29:[7Creturn s:BufInit(fn)
line 30:     endif
line 31:     let ofn = fn
line 32:     let fn = fnamemodify(ofn,':s?\(.*\)[\/]\(app\|config\|db\|doc\|extras\|features\|lib\|log\|public\|script\|spec\|stories\|test\|tmp\|vendor\)\($\|[\/].*$\)?\1?')
line 33:   endwhile
line 27:   while fn != ofn
line 28:     if filereadable(fn . "/config/environment.rb")
line 29:[7Creturn s:BufInit(fn)
line 30:     endif
line 31:     let ofn = fn
line 32:     let fn = fnamemodify(ofn,':s?\(.*\)[\/]\(app\|config\|db\|doc\|extras\|features\|lib\|log\|public\|script\|spec\|stories\|test\|tmp\|vendor\)\($\|[\/].*$\)?\1?')
line 33:   endwhile
line 34:   return 0
function <SNR>15_Detect returning #0
continuing in VimEnter Auto commands for "*"
line 0:  endif | if exists("b:rails_root") | silent doau User BufEnterRails | endif
line 0:  if exists("b:rails_root") | silent doau User BufEnterRails | endif
line 0:  silent doau User BufEnterRails | endif
line 0:  endif
Executing VimEnter Auto commands for "*"[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lautocommand call s:abolish_setup()[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lline 0: call s:abolish_setup()
calling function <SNR>15_abolish_setup()
line 1:   if exists('g:Abolish') && has_key(g:Abolish,'Coercions')
line 2:     if !has_key(g:Abolish.Coercions,'l')
line 3:[7Clet g:Abolish.Coercions.l = s:function('s:abolish_l')
line 4:     endif
line 5:     if !has_key(g:Abolish.Coercions,'t')
line 6:[7Clet g:Abolish.Coercions.t = s:function('s:abolish_t')
line 7:     endif
line 8:   endif
function <SNR>15_abolish_setup returning #0
continuing in VimEnter Auto commands for "*"
[?1000lPress ENTER or type command to continue[?12l[?25h[?1000h[?25lExecuting CursorMoved Auto commands for "*"[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lautocommand call s:Highlight_Matching_Pair()[?1000l
Press ENTER or type command to continue[?12l[?25h[?1000h
[?25lline 0: call s:Highlight_Matching_Pair()
calling function <SNR>18_Highlight_Matching_Pair()
line 1:   " Remove any previous match.
line 2:   if exists('w:paren_hl_on') && w:paren_hl_on
line 3:     3match none
line 4:     let w:paren_hl_on = 0
line 5:   endif
line 6:
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12:
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17:
line 18:   let c = getline(c_lnum)[c_col - 1]
line 19:   let plist = split(&matchpairs, '.\zs[:,]')
line 20:   let i = index(plist, c)
line 21:   if i < 0
line 22:     " not found, in Insert mode try character before the cursor
line 23:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 24:[7Clet before = 1
line 25:[7Clet c = getline(c_lnum)[c_col - 2]
line 26:[7Clet i = index(plist, c)
line 27:     endif
line 28:     if i < 0
line 29:[7C" not found, nothing to do
line 30:[7Creturn
function <SNR>18_Highlight_Matching_Pair returning #0
continuing in CursorMoved Auto commands for "*"
[27m[m[H[2J[1;1H[1m[33m  1 [m[1m[34m$
~                                                                                                                                                                                                                                                                              [3;1H~                                                                                                                                                                                                                                                                              [4;1H~                                                                                                                                                                                                                                                                              [5;1H~                                                                                                                                                                                                                                                                              [6;1H~                                                                                                                                                                                                                                                                              [7;1H~                                                                                                                                                                                                                                                                              [8;1H~                                                                                                                                                                                                                                                                              [9;1H~                                                                                                                                                                                                                                                                              [10;1H~                                                                                                                                                                                                                                                                              [11;1H~                                                                                                                                                                                                                                                                              [12;1H~                                                                                                                                                                                                                                                                              [13;1H~                                                                                                                                                                                                                                                                              [14;1H~                                                                                                                                                                                                                                                                              [15;1H~                                                                                                                                                                                                                                                                              [16;1H~                                                                                                                                                                                                                                                                              [17;1H~                                                                                                                                                                                                                                                                              [18;1H~                                                                                                                                                                                                                                                                              [19;1H~                                                                                                                                                                                                                                                                              [20;1H~                                                                                                                                                                                                                                                                              [21;1H~                                                                                                                                                                                                                                                                              [22;1H~                                                                                                                                                                                                                                                                              [23;1H~                                                                                                                                                                                                                                                                              [24;1H~                                                                                                                                                                                                                                                                              [25;1H~                                                                                                                                                                                                                                                                              [26;1H~                                                                                                                                                                                                                                                                              [27;1H~                                                                                                                                                                                                                                                                              [28;1H~                                                                                                                                                                                                                                                                              [29;1H~                                                                                                                                                                                                                                                                              [30;1H~                                                                                                                                                                                                                                                                              [31;1H~                                                                                                                                                                                                                                                                              [32;1H~                                                                                                                                                                                                                                                                              [33;1H~                                                                                                                                                                                                                                                                              [34;1H~                                                                                                                                                                                                                                                                              [35;1H~                                                                                                                                                                                                                                                                              [36;1H~                                                                                                                                                                                                                                                                              [37;1H~                                                                                                                                                                                                                                                                              [38;1H~                                                                                                                                                                                                                                                                              [39;1H~                                                                                                                                                                                                                                                                              [40;1H~                                                                                                                                                                                                                                                                              [41;1H~                                                                                                                                                                                                                                                                              [42;1H~                                                                                                                                                                                                                                                                              [43;1H~                                                                                                                                                                                                                                                                              [44;1H~                                                                                                                                                                                                                                                                              [45;1H~                                                                                                                                                                                                                                                                              [46;1H~                                                                                                                                                                                                                                                                              [47;1H~                                                                                                                                                                                                                                                                              [48;1H~                                                                                                                                                                                                                                                                              [49;1H~                                                                                                                                                                                                                                                                              [50;1H~                                                                                                                                                                                                                                                                              [51;1H~                                                                                                                                                                                                                                                                              [52;1H~                                                                                                                                                                                                                                                                              [53;1H~                                                                                                                                                                                                                                                                              [54;1H~                                                                                                                                                                                                                                                                              [55;1H~                                                                                                                                                                                                                                                                              [56;1H~                                                                                                                                                                                                                                                                              [57;1H~                                                                                                                                                                                                                                                                              [58;1H~                                                                                                                                                                                                                                                                              [59;1H~                                                                                                                                                                                                                                                                              [60;1H~                                                                                                                                                                                                                                                                              [61;1H~                                                                                                                                                                                                                                                                              [62;1H~                                                                                                                                                                                                                                                                              [63;1H~                                                                                                                                                                                                                                                                              [64;1H~                                                                                                                                                                                                                                                                              [65;1H~                                                                                                                                                                                                                                                                              [66;1H~                                                                                                                                                                                                                                                                              [67;1H~                                                                                                                                                                                                                                                                              [68;1H~                                                                                                                                                                                                                                                                              [m[69;1H[1m[7m[No Name]                                                                                                                                                                                                                                                    0,0-1          All[m[29;128HVIM - Vi IMproved[31;131Hversion 7.3[32;124Hby Bram Moolenaar et al.[33;115HVim is open source and freely distributable[35;122HHelp poor children in Uganda![36;113Htype  :help iccf[1m[34m<Enter>[m       for information [38;113Htype  :q[1m[34m<Enter>[m               to exit         [39;113Htype  :help[1m[34m<Enter>[m  or  [1m[34m<F1>[m  for on-line help[40;113Htype  :help version7[1m[34m<Enter>[m   for version info[1;5H[?12l[?25h[?25l[70;1H:[?12l[?25hq[?25l[?12l[?25h
[?25lWriting viminfo file "/home/vimtest/.viminfo"[?1000l[?1l>[?12l[?25h[?1049l
